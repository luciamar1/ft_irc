// ===== Archivo: ./lib/Server.hpp ===== //
#ifndef IRC_SERVER_HPP
#define IRC_SERVER_HPP

#include <string>
#include <vector>
#include <poll.h>
#include "CommandHandler.hpp"
#include "BookClient.hpp"  // Incluimos la clase Book
#include "ChannelBook.hpp"

class CommandHandler;
// Definición de la clase IRCServer
class IRCServer {
    private:
        // Atributos del servidor
        int server_fd;  // Descriptor de archivo para el socket del servidor
        int port;       // Puerto en el que el servidor escucha
        std::string password;  // Contraseña del servidor
        std::vector<struct pollfd> clients;  // Lista de clientes conectados
        BookClient clients_info;  // Usamos Book para almacenar la información de los clientes
        ChannelBook channels;
    
public:
    // Constructor y Destructor
    IRCServer(int port, const std::string& password);
    ~IRCServer();

    void safeSend(int client_fd, const std::string& message);

    // Métodos para manejar clientes y mensajes
    void acceptClient();
    void removeClient(int client_fd);
    void handleClientData(int client_fd, CommandHandler& handler);
    void run();

    // Métodos de interacción con clientes
    int nickExist(std::string _nick);

    BookClient&  getClientsBook();
    ChannelBook&  getChannelsBook();


    // Métodos para obtener y configurar información de clientes

};

#endif  // IRC_SERVER_HPP



// ===== Archivo: ./lib/BookClient.hpp ===== //
#ifndef BOOK_CLIENT_HPP
#define BOOK_CLIENT_HPP

#include <map>
#include "Client.hpp"

class BookClient 
{
    private:
        std::map<int, Client *> clients;

    public:
        BookClient();
        ~BookClient();
        bool addClient(int fd, std::string nick, std::string user, AuthStage stage) ;
        void    removeClient(int fd);
        bool    nickExists(const std::string& nick);
        bool    fdExists(int fd);

        Client* getClientByNick(const std::string& nick);
        Client* getClient(int fd);
        std::map<int, Client *>&    getmap();
        void printbook();
};

#endif



// ===== Archivo: ./lib/ChannelBook.hpp ===== //
#ifndef CHANNELBOOK_HPP
#define CHANNELBOOK_HPP

#include <map>
#include <string>
#include "Channel.hpp"

class ChannelBook {
    
    private:
        std::map<std::string, Channel*> _channels;
public:
    ~ChannelBook();
    Channel* getChannel(const std::string& name);
    bool addChannel(const std::string& name);
    void removeChannel(const std::string& name);
    bool channelExists(const std::string& name) const;
    std::map<std::string, Channel*>& getAllChannels();
};

#endif



// ===== Archivo: ./lib/Client.hpp ===== //
#ifndef CLIENT_HPP
#define CLIENT_HPP

#include <string>
#include <set>

enum AuthStage 
{
    WAITING_PASSWORD,
    WAITING_NICKNAME,
    WAITING_USERNAME,
    CONNECTED
};

class Client {
private:
    int fd;
    // static const size_t MAX_BUFFER_SIZE = 10240; // 10KB
    std::string nickname;
    std::string realname;
    std::string buffer;
    AuthStage stage;
    std::set<std::string> joinedChannels;
    std::string output_buffer; 
public:
    static const size_t MAX_BUFFER_SIZE = 10240;
    Client();
    Client(int fd, std::string _nick,std::string _user,  AuthStage _stage = WAITING_PASSWORD);

    std::string& getOutputBuffer();
    void safeSend(const std::string& message);

    int getFd() const;
    void setFd(int _fd);

    AuthStage getStage() const ;
    void setStage(AuthStage s) ;

    std::string getNickname() const;
    void setNickname(const std::string& nick);

    std::string getRealname() const;
    void setRealname(const std::string& name);

    std::string& getBuffer();

    void joinChannel(const std::string& channelName);
    void leaveChannel(const std::string& channelName);
    bool isInChannel(const std::string& channelName) const;
    const std::set<std::string>& getJoinedChannels() const;

};

#endif



// ===== Archivo: ./lib/Channel.hpp ===== //

// Channel.hpp
#ifndef CHANNEL_HPP
#define CHANNEL_HPP

#include <string>
#include <map>
#include <set>
#include <vector>
#include <sys/socket.h> 

class Client; // forward declaration

class Channel {
private:
	std::string _name;
	std::string _topic;
	std::string _password;
	size_t      _userLimit;
	bool        _inviteOnly;
	bool        _topicRestricted;

	std::set<Client*> _clients;
	std::set<Client*> _operators;
	std::set<Client*> _invited;

public:
	Channel(const std::string& name);

	// Getters y setters
	const std::string& getName() const;
	const std::string& getTopic() const;
	void setTopic(const std::string& topic);

	bool isInviteOnly() const;
	void setInviteOnly(bool val);

	bool isTopicRestricted() const;
	void setTopicRestricted(bool val);

	const std::string& getPassword() const;
	void setPassword(const std::string& pass);

	size_t getUserLimit() const;
	void setUserLimit(size_t limit);

	// Gestión de usuarios
	void addClient(Client* client);
	void removeClient(Client* client);
	bool hasClient(Client* client) const;

	// Operadores
	void addOperator(Client* client);
	void removeOperator(Client* client);
	bool isOperator(Client* client) const;

	// Invitados
	void inviteClient(Client* client);
	bool isInvited(Client* client) const;
 	void removeInvited(Client* client);
	
	const std::set<Client*>& getClients() const;

	void sendToAll(const std::string& message, Client* sender);

	//Mode
	void setMode(char mode, bool enabled, const std::string& arg = "");
	std::string getModeString() const;
};

#endif



// ===== Archivo: ./lib/CommandHandler.hpp ===== //
#ifndef COMMAND_HANDLER_HPP
#define COMMAND_HANDLER_HPP

#include <string>
#include <vector>
#include "Server.hpp"

class IRCServer;

class CommandHandler {
public:
    struct ParsedMessage {
        std::string command;
        std::vector<std::string> params;
        std::string trailing;
    };

    CommandHandler();
    ~CommandHandler();

    static ParsedMessage parseMessage(const std::string& raw_message);
    void handleClientMessage(int client_fd, const std::string& message, IRCServer& server);

    // Métodos de comandos
    void handleNickCommand(int client_fd, const std::string& new_nick, IRCServer& server);
    void handlePrivMsgCommand(int client_fd, const std::string& target, const std::string& message, IRCServer& server);
    void handlePartCommand(int client_fd, const std::string& channel_name, const std::string& reason, IRCServer& server);
    void handleJoinCommand(int client_fd, const std::string& channel_name_raw,const std::string& password, IRCServer& server);
    void sendToAllClients(const std::string& message, int sender_fd, IRCServer& server);
    void handleModeCommand(int client_fd, const std::string& target, const std::string& mode_str, const std::vector<std::string>& args,IRCServer& server) ;
    void handleKickCommand(int client_fd, const std::string& channel_name, const std::string& user, const std::string& reason, IRCServer& server);
    void handleInviteCommand(int client_fd, const std::string& nick, const std::string& channel_name, IRCServer& server);
    void handleTopicCommand(int client_fd, const std::string& channel_name, const std::string& new_topic, IRCServer& server); 
    void safeSend(int client_fd, const std::string& message, IRCServer& server);

    private:
    // Helper para enviar errores
    void sendError(int client_fd, const std::string& code, const std::string& msg, IRCServer& server);
};  


#endif



// #ifndef COMMAND_HANDLER_HPP
// #define COMMAND_HANDLER_HPP

// #include <string>
// #include "Server.hpp"

// class IRCServer;
// class CommandHandler {

// public:
//     CommandHandler();
//     ~CommandHandler();

//     void handleNickCommand(int client_fd, const std::string& new_nick, IRCServer& server);
//     void handleClientMessage(int client_fd, const std::string& message, IRCServer& server);
//     void sendToAllClients(const std::string& message, int sender_fd, IRCServer& server);
//     //void handlePrivMsgCommand(int client_fd, const std::string& target, const std::string& message, IRCServer& server);
//     void handlePrivMsgCommand(int client_fd, const std::string& params, IRCServer& server);
//     void handlePartCommand(int client_fd, const std::string& channel_name, const std::string& reason, IRCServer& server);
//     void handleJoinCommand(int client_fd, const std::string& channel_name_raw, IRCServer& server);
// };

// #endif



// ===== Archivo: ./src/ChannelBook.cpp ===== //
#include "ChannelBook.hpp"
#include <iostream>

Channel* ChannelBook::getChannel(const std::string& name) {
    if (_channels.find(name) != _channels.end())
        return _channels[name];
    return NULL;
}

ChannelBook::~ChannelBook() {
    for (std::map<std::string, Channel*>::iterator it = _channels.begin(); it != _channels.end(); ++it) {
        delete it->second;
    }
}

bool ChannelBook::addChannel(const std::string& name) 
{
    if (_channels.find(name) != _channels.end()) return true;

    Channel* new_channel = NULL;
    try {
        new_channel = new Channel(name);
    } 
    catch (const std::bad_alloc& e) { 
        std::cerr << "Error: could not allocate memory for new Channel: " << e.what() << std::endl;

        return false;
    }

    try {
        _channels.insert(std::make_pair(name, new_channel));
    } 
    catch (...) {
        delete new_channel;
        return false;
    }
    return true;

}

void ChannelBook::removeChannel(const std::string& name) {
    std::map<std::string, Channel*>::iterator it = _channels.find(name);
    if (it != _channels.end()) {
        delete it->second;
        _channels.erase(it);
    }
}

bool ChannelBook::channelExists(const std::string& name) const {
    return _channels.find(name) != _channels.end();
}

std::map<std::string, Channel*>& ChannelBook::getAllChannels() {
    return _channels;
}




// ===== Archivo: ./src/CommandHandler.cpp ===== //
#include "CommandHandler.hpp"
#include <sstream>
#include <iostream>
#include <sys/socket.h>
#include <unistd.h>
#include <algorithm>  
#include "CommandHandler.hpp"
#include <cstring>
#include <cctype> 
#include "CommandHandler.hpp"
#include <cstdlib>
#include <map>

CommandHandler::CommandHandler()
{
    
}
CommandHandler::~CommandHandler()
{
    
}

std::string intToString(int value) {
    std::ostringstream oss;
    oss << value;
    return oss.str();
}

void CommandHandler::sendError(int client_fd, const std::string& code, const std::string& msg, IRCServer& server)
{
    std::string msg_error = "code error: " + code +" " + msg;
    safeSend(client_fd, msg_error, server); 
}

void CommandHandler::safeSend(int client_fd, const std::string& message, IRCServer& server) {
    Client* client = server.getClientsBook().getClient(client_fd);
    if (client) {
        client->getOutputBuffer() += message;
    }
}



void CommandHandler::handleModeCommand(int client_fd, const std::string& target, 
                                      const std::string& mode_str, 
                                      const std::vector<std::string>& args,
                                      IRCServer& server) {
    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client || client->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered", server);
        return;
    }

    // Manejo para canales
    if (!target.empty() && target[0] == '#') {
        Channel* channel = server.getChannelsBook().getChannel(target);
        if (!channel) {
            sendError(client_fd, "403", target + " :No such channel", server);
            return;
        }

        // Verificar privilegios de operador
        if (!channel->isOperator(client)) {
            sendError(client_fd, "482", target + " :You're not channel operator", server);
            return;
        }

        // Consulta de modos (sin cambios)
        if (mode_str.empty()) {
            std::string reply = ":server 324 " + client->getNickname() + " " + target + " " + channel->getModeString() + "\r\n";
            safeSend(client_fd, reply, server);
            return;
        }
        

        // Procesar secuencia de modos
        char current_sign = '+';
        size_t arg_index = 0;
        std::string changes;
        std::string mode_args;
        bool valid_mode = true;

        for (size_t i = 0; i < mode_str.size() && valid_mode; ++i) 
        {
            char mode_char = mode_str[i];
            
            // Manejar cambio de signo (+/-)
            if (mode_char == '+' || mode_char == '-') {
                current_sign = mode_char;
                continue;
            }

            // Procesar cada modo específico
            switch (mode_char) 
            {
                case 'i': // Modo invite-only
                case 't': // Modo topic restringido
                    channel->setMode(mode_char, current_sign == '+');
                    changes += current_sign;
                    changes += mode_char;
                    break;
                    
                case 'k': // Contraseña del canal
                    if (current_sign == '+') {
                        if (arg_index >= args.size()) {
                            sendError(client_fd, "461", "MODE k :Not enough parameters", server);
                            valid_mode = false;
                            break;
                        }
                        channel->setMode(mode_char, true, args[arg_index]);
                        mode_args += " " + args[arg_index++];
                    } else {
                        channel->setMode(mode_char, false);
                    }
                    changes += current_sign;
                    changes += mode_char;
                    break;

                case 'o': // Privilegios de operador
                {
                    if (arg_index >= args.size()) {
                        sendError(client_fd, "461", "MODE o :Not enough parameters", server);
                        valid_mode = false;
                        break;
                    }
                    
                    Client* target_client = server.getClientsBook().getClientByNick(args[arg_index]);
                    if (!target_client) {
                        sendError(client_fd, "401", args[arg_index] + " :No such nick", server);
                        valid_mode = false;
                        break;
                    }

                    if (current_sign == '+') {
                        channel->addOperator(target_client);
                    } else {
                        channel->removeOperator(target_client);
                    }
                    changes += current_sign;
                    changes += mode_char;
                    mode_args += " " + args[arg_index++];
                    break;
                }

                case 'l': // Límite de usuarios
                    if (current_sign == '+') {
                        if (arg_index >= args.size()) {
                            sendError(client_fd, "461", "MODE l :Not enough parameters", server);
                            valid_mode = false;
                            break;
                        }
                        const std::string& limit = args[arg_index];
                        if (!std::isdigit(limit[0])) {
                            sendError(client_fd, "696", target + " l :Invalid limit format", server);
                            valid_mode = false;
                            break;
                        }
                        channel->setMode(mode_char, true, limit);
                        mode_args += " " + limit;
                        arg_index++;
                    } else {
                        channel->setMode(mode_char, false);
                    }
                    changes += current_sign;
                    changes += mode_char;
                    break;

                default: // Modo desconocido
                    sendError(client_fd, "472", std::string(1, mode_char) + " :is unknown mode char", server);
                    valid_mode = false;
                    break;
            }
        }
 // ... (resto del código sin cambios) ...

        // Notificar cambios si fueron válidos
        if (valid_mode && !changes.empty()) {
            std::string msg = ":" + client->getNickname() + "!" + client->getRealname() + 
                            "@localhost MODE " + target + " " + changes + mode_args + "\r\n";
            channel->sendToAll(msg, NULL);
        }
    } else {
        sendError(client_fd, "502", ":User modes not supported", server);
    }
}

void CommandHandler::handleTopicCommand(int client_fd, const std::string& channel_name, 
                                       const std::string& new_topic, IRCServer& server) {
    // 1. Verificar cliente autenticado
    Client* client_ptr = server.getClientsBook().getClient(client_fd);
    if (!client_ptr || client_ptr->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered", server);
        return;
    }

    // 2. Validar parámetros mínimos
    if (channel_name.empty()) {
        sendError(client_fd, "461", "TOPIC :Not enough parameters", server);
        return;
    }

    // 3. Verificar que el canal existe
    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        sendError(client_fd, "403", channel_name + " :No such channel", server);
        return;
    }

    // 4. Verificar que el cliente está en el canal
    if (!channel->hasClient(client_ptr)) {
        sendError(client_fd, "442", channel_name + " :You're not on that channel", server);
        return;
    }

    // 5. Si no se especifica nuevo tema: mostrar tema actual
    if (new_topic.empty()) {
        if (channel->getTopic().empty()) {
            std::string reply = ":server 331 " + client_ptr->getNickname() + " " + channel_name + " :No topic is set\r\n";
            safeSend(client_fd, reply, server);
        } else {
            std::string reply = ":server 332 " + client_ptr->getNickname() + " " + channel_name + " :" + channel->getTopic() + "\r\n";
            safeSend(client_fd, reply, server);
        }
        return;
    }

    // 6. Verificar permisos para cambiar el tema
    if (channel->isTopicRestricted() && !channel->isOperator(client_ptr)) {
        sendError(client_fd, "482", channel_name + " :You must be channel operator to change the topic", server);
        return;
    }

    // 7. Actualizar el tema
    channel->setTopic(new_topic);

    // 8. Notificar a todos en el canal
    std::string msg = ":" + client_ptr->getNickname() + "!" + client_ptr->getRealname() + 
                     "@localhost TOPIC " + channel_name + " :" + new_topic + "\r\n";
    channel->sendToAll(msg, NULL);

    // 9. Confirmación al cliente que cambió el tema
    std::string rpl = ":server 333 " + client_ptr->getNickname() + " " + channel_name + 
                     " " + client_ptr->getNickname() + " " + intToString(time(NULL)) + "\r\n";
    safeSend(client_fd, rpl, server);
}

void CommandHandler::handleInviteCommand(int client_fd, const std::string& nick, 
                                        const std::string& channel_name, IRCServer& server) {
    // 1. Verificar cliente autenticado
    Client* inviter = server.getClientsBook().getClient(client_fd);
    if (!inviter || inviter->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered", server);
        return;
    }

    // 2. Validar parámetros
    if (nick.empty() || channel_name.empty()) {
        sendError(client_fd, "461", "INVITE :Not enough parameters", server);
        return;
    }

    // 3. Verificar que el canal existe
    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        sendError(client_fd, "403", channel_name + " :No such channel", server);
        return;
    }

    // 4. Verificar que el inviter está en el canal
    if (!channel->hasClient(inviter)) {
        sendError(client_fd, "442", channel_name + " :You're not on that channel", server);
        return;
    }

    // 5. Verificar permisos
    if (channel->isInviteOnly() && !channel->isOperator(inviter)) {
        sendError(client_fd, "482", channel_name + " :You must be channel operator", server);
        return;
    }

    // 6. Verificar que el usuario objetivo existe
    Client* target = server.getClientsBook().getClientByNick(nick);
    if (!target) {
        sendError(client_fd, "401", nick + " :No such nick", server);
        return;
    }

    // 7. Verificar que no está ya en el canal
    if (channel->hasClient(target)) {
        sendError(client_fd, "443", nick + " " + channel_name + " :is already on channel", server);
        return;
    }

    // 8. Invitar al cliente
    channel->inviteClient(target);

    // 9. Mensaje al invitado
    std::string msg = ":" + inviter->getNickname() + "!" + inviter->getRealname() + 
                     "@localhost INVITE " + nick + " :" + channel_name + "\r\n";
    safeSend(target->getFd(), msg, server);
    
    // 10. Mensaje de confirmación al inviter
    std::string rpl = ":server 341 " + inviter->getNickname() + " " + nick + " " + channel_name + "\r\n";
    safeSend(client_fd, rpl, server);
    
    // 11. Mensaje a operadores del canal
    if (channel->isInviteOnly()) {
        std::string op_msg = ":" + inviter->getNickname() + "!" + inviter->getRealname() + 
                            "@localhost INVITE " + nick + " " + channel_name + "\r\n";
        channel->sendToAll(op_msg, inviter);
    }
}

void CommandHandler::handleKickCommand(int client_fd, const std::string& channel_name, 
                                      const std::string& user, const std::string& reason, 
                                      IRCServer& server) {
    // 1. Verificar cliente autenticado
    Client* issuer = server.getClientsBook().getClient(client_fd);
    if (!issuer || issuer->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered", server);
        return;
    }

    // 2. Validar parámetros mínimos
    if (channel_name.empty() || user.empty()) {
        sendError(client_fd, "461", "KICK :Not enough parameters", server);
        return;
    }

    // 3. Verificar que el canal existe
    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        sendError(client_fd, "403", channel_name + " :No such channel", server);
        return;
    }

    // 4. Verificar que el solicitante es operador
    if (!channel->isOperator(issuer)) {
        sendError(client_fd, "482", channel_name + " :You're not channel operator", server);
        return;
    }

    // 5. Verificar que el usuario objetivo existe y está en el canal
    Client* target = server.getClientsBook().getClientByNick(user);
    if (!target) {
        sendError(client_fd, "401", user + " :No such nick", server);
        return;
    }
    if (!channel->hasClient(target)) {
        sendError(client_fd, "441", user + " " + channel_name + " :They aren't on that channel", server);
        return;
    }

    // 6. Construir mensaje de expulsión
    std::string kick_msg = ":" + issuer->getNickname() + "!" + issuer->getRealname() +
                          "@localhost KICK " + channel_name + " " + user;
    if (!reason.empty()) kick_msg += " :" + reason;
    kick_msg += "\r\n";

    // 7. Enviar notificación a todos en el canal
    channel->sendToAll(kick_msg, NULL);

    // 8. Eliminar al usuario del canal
    channel->removeClient(target);
    target->leaveChannel(channel_name);

    // 9. Si el usuario era operador, quitar privilegios
    if (channel->isOperator(target)) {
        channel->removeOperator(target);
    }

    // 11. Eliminar canal si queda vacío
    if (channel->getClients().empty()) {
        server.getChannelsBook().removeChannel(channel_name);
    }
}



CommandHandler::ParsedMessage CommandHandler::parseMessage(const std::string& raw_message) {
    ParsedMessage result;
    
    // 1. Limitar tamaño máximo según RFC 1459 (512 bytes)
    if (raw_message.size() > 512) {
        result.command = "ERROR";
        result.trailing = "Message too long";
        return result;
    }
    
    // 2. Filtrar caracteres no ASCII y secuencias de escape
    std::string cleaned_message;
    for (size_t i = 0; i < raw_message.size(); ++i) {
        const char c = raw_message[i];
        // Permitir caracteres ASCII imprimibles (32-126) y \r, \n
        if ((c >= 32 && c <= 126) || c == '\r' || c == '\n' || c == '\t') {
            cleaned_message += c;
        }
        // Convertir secuencias de escape a espacios
        else if (c == 27) {  // ESC character (inicio de secuencia ANSI)
            while (i + 1 < raw_message.size() && 
                  (raw_message[i+1] == '[' || 
                   (raw_message[i+1] >= 'A' && raw_message[i+1] <= 'Z') || 
                   (raw_message[i+1] >= 'a' && raw_message[i+1] <= 'z'))) {
                i++;
            }
            cleaned_message += ' ';  // Reemplazar secuencia por espacio
        }
    }
    
    std::istringstream iss(cleaned_message);
    std::string token;
    
    // 3. Parsear comando principal
    if (!(iss >> result.command)) {
        result.command = "EMPTY";
        return result;
    }
    
    // 4. Parsear parámetros y trailing con límite máximo
    int param_count = 0;
    const int MAX_PARAMS = 10;
    
    while (iss >> token && param_count < MAX_PARAMS) {
        if (token[0] == ':') {
            // CORRECCIÓN: Capturar trailing completo incluyendo espacios
            result.trailing = token.substr(1);  // Quitar el ':' inicial
            
            // Leer el resto de la línea incluyendo espacios
            std::string remainder;
            std::getline(iss, remainder);
            
            // Añadir el resto si hay más contenido
            if (!remainder.empty()) {
                // Eliminar espacio inicial si existe
                if (!remainder.empty() && remainder[0] == ' ') {
                    remainder = remainder.substr(1);
                }
                result.trailing += " " + remainder;
            }
            
            // Eliminar \r y \n del final
            size_t end = result.trailing.find_last_not_of("\r\n");
            if (end != std::string::npos) {
                result.trailing = result.trailing.substr(0, end + 1);
            }
            break;
        }
        
        // Limitar tamaño de cada parámetro
        if (token.size() > 50) {
            token = token.substr(0, 50);
        }
        
        result.params.push_back(token);
        param_count++;
    }
    
    // 5. Limitar tamaño del trailing
    if (result.trailing.size() > 300) {
        result.trailing = result.trailing.substr(0, 300);
    }
    
    return result;
}


// Modificar handleClientMessage para usar el parser
std::string cleanInput(const std::string& input) 
{
    std::string cleaned;
    for (size_t i = 0; i < input.size(); ++i) {
        const char c = input[i];
        if (c >= 32 && c <= 126) { // Solo caracteres ASCII imprimibles
            cleaned += c;
        }
    }
    return cleaned;
}


void CommandHandler::handleClientMessage(int client_fd, const std::string& message, IRCServer& server) {
    std::string cleaned_msg = cleanInput(message);
    ParsedMessage parsed = parseMessage(cleaned_msg);

    if (parsed.command == "NICK") {
        handleNickCommand(client_fd, parsed.params.empty() ? "" : parsed.params[0], server);
    } 
    else if (parsed.command == "QUIT") {
        server.removeClient(client_fd);
    } 
    else if (parsed.command == "JOIN") {
        std::string channel = parsed.params.empty() ? "" : parsed.params[0];
        std::string password = parsed.params.size() > 1 ? parsed.params[1] : "";
        handleJoinCommand(client_fd, parsed.params.empty() ? "" : parsed.params[0], password, server);
    } 
    else if (parsed.command == "PRIVMSG") {
        if (parsed.params.empty() || parsed.trailing.empty()) {
            sendError(client_fd, "411", "PRIVMSG :Not enough parameters", server);
            return;
        }
        handlePrivMsgCommand(client_fd, parsed.params[0], parsed.trailing, server);
    } 
    else if (parsed.command == "PART") {
        handlePartCommand(client_fd, parsed.params.empty() ? "" : parsed.params[0], parsed.trailing, server);
    }
    else if (parsed.command == "MODE") {
        // Verificación robusta de parámetros
        if (parsed.params.empty()) {
            sendError(client_fd, "461", "MODE :Not enough parameters", server);
            return;
        }
        
        const std::string& target = parsed.params[0];
        std::string modes = "";
        std::vector<std::string> args;
        
        // Manejo eficiente de modos y argumentos
        if (parsed.params.size() > 1) {
            modes = parsed.params[1];
            
            // Copia directa de argumentos sin creación temporal
            if (parsed.params.size() > 2) {
                args.reserve(parsed.params.size() - 2);  // Optimización de memoria
                for (size_t i = 2; i < parsed.params.size(); ++i) {
                    args.push_back(parsed.params[i]);
                }
            }
        }
    
        handleModeCommand(client_fd, target, modes, args, server);
    }
    else if (parsed.command == "INVITE") {
        if (parsed.params.size() < 2) {
            sendError(client_fd, "461", "INVITE :Not enough parameters", server);
            return;
        }
        handleInviteCommand(client_fd, parsed.params[0], parsed.params[1], server);
    }
    else if (parsed.command == "KICK") {
        std::string channel = parsed.params.size() > 0 ? parsed.params[0] : "";
        std::string user = parsed.params.size() > 1 ? parsed.params[1] : "";
        std::string reason = parsed.trailing;
        handleKickCommand(client_fd, channel, user, reason, server);
    }
    else if (parsed.command == "TOPIC") {
        std::string channel = parsed.params.empty() ? "" : parsed.params[0];
        std::string new_topic = parsed.trailing;
        handleTopicCommand(client_fd, channel, new_topic, server);
    }

}

void CommandHandler::handlePartCommand(int client_fd, const std::string& channel_name, 
                                      const std::string& reason, IRCServer& server) {
    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client || client->getStage() != CONNECTED) {
        std::string err_msg = ":server 451 * :You have not registered\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // Validar formato del canal
    if (channel_name.empty() || channel_name[0] != '#') {
        std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :No such channel\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :No such channel\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // Verificar si el cliente está en el canal
    if (!channel->hasClient(client)) {
        std::string err_msg = ":server 442 " + client->getNickname() + " " + channel_name + " :You're not on that channel\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // Notificar a los miembros del canal
    std::string part_msg = ":" + client->getNickname() + "!~" + client->getRealname() + 
                          "@localhost PART " + channel_name;
    if (!reason.empty()) part_msg += " :" + reason;
    part_msg += "\r\n";
    
    channel->sendToAll(part_msg, NULL);

    // Eliminar al cliente del canal
    channel->removeClient(client);
    client->leaveChannel(channel_name);

    // Si el canal queda vacío, eliminarlo
    if (channel->getClients().empty()) {
        server.getChannelsBook().removeChannel(channel_name);
    }
}


void CommandHandler::handlePrivMsgCommand(int client_fd, const std::string& target, 
                                         const std::string& message, IRCServer& server) {
    Client* sender = server.getClientsBook().getClient(client_fd);
    
    // 1. Validar estado del cliente
    if (!sender || sender->getStage() != CONNECTED) {
        std::string err_msg = ":server 451 * :You have not registered\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // 2. Validar parámetros
    if (target.empty()) {
        std::string err_msg = ":server 411 " + sender->getNickname() + " :No recipient given\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }
    
    if (message.empty()) {
        std::string err_msg = ":server 412 " + sender->getNickname() + " :No text to send\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // 3. Determinar tipo de destino
    if (target[0] == '#') {
        // Mensaje a canal
        Channel* channel = server.getChannelsBook().getChannel(target);
        
        if (!channel) {
            std::string err_msg = ":server 403 " + sender->getNickname() + " " + target + " :No such channel\r\n";
            safeSend(client_fd, err_msg, server);
            return;
        }
        
        if (!channel->hasClient(sender)) {
            std::string err_msg = ":server 404 " + sender->getNickname() + " " + target + " :Cannot send to channel\r\n";
            safeSend(client_fd, err_msg, server);
            return;
        }

        // Construir y enviar mensaje
        std::string msg = ":" + sender->getNickname() + "!" + sender->getRealname() + 
                         " PRIVMSG " + target + " :" + message + "\r\n";
        channel->sendToAll(msg, sender);
    } else {
        // Mensaje privado
        Client* receiver = server.getClientsBook().getClientByNick(target);
        
        if (!receiver || receiver->getStage() != CONNECTED) {
            std::string err_msg = ":server 401 " + sender->getNickname() + " " + target + " :No such nick/channel\r\n";
            safeSend(client_fd, err_msg, server);
            return;
        }

        // Construir y enviar mensaje
        std::string msg = ":" + sender->getNickname() + "!" + sender->getRealname() + "@" + 
                         " PRIVMSG " + target + " :" + message + "\r\n";
        safeSend(receiver->getFd(), msg, server);
    }
}


void CommandHandler::handleNickCommand(int client_fd, const std::string& new_nick, IRCServer &server) 
{
    std::string _nick(new_nick);

    // Limpiar el nuevo nick
    _nick.erase(_nick.find_last_not_of("\r\n") + 1);  
    _nick.erase(0, _nick.find_first_not_of(" ")); 
    _nick.erase(_nick.find_last_not_of(" ") + 1); 

    if (_nick.empty()) 
    {
        std::string error_msg = "ERROR: Nickname cannot be empty.\n";
        safeSend(client_fd, error_msg, server);
        return;
    }

    if(server.getClientsBook().nickExists(_nick))
    {
        std::string error_msg = "ERROR: Nickname already in use.\n";
        safeSend(client_fd, error_msg, server);
        return;
    }

    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client) 
    {
        std::cerr << "ERROR: Client pointer is NULL for fd " << client_fd << std::endl;
        return;
    }
    
    // Guardar el nick antiguo para notificación
    std::string old_nick = client->getNickname();
    
    // Actualizar el nickname
    client->setNickname(_nick);
    
    // Notificar al cliente que cambió su nick
    std::string success_msg = ":" + old_nick + " NICK :" + _nick + "\r\n";
    safeSend(client_fd, success_msg, server);

    // Notificar a todos los canales donde está presente
    const std::set<std::string>& joinedChannels = client->getJoinedChannels();
    for (std::set<std::string>::const_iterator it = joinedChannels.begin(); it != joinedChannels.end(); ++it) 
    {
        Channel* channel = server.getChannelsBook().getChannel(*it);
        if (channel) 
        {
            // Construir mensaje en formato IRC estándar
            std::string msg = ":" + old_nick + "!" + client->getRealname() + 
                             "@localhost NICK :" + _nick + "\r\n";
            channel->sendToAll(msg, client);
        }
    }
    
    std::cout << "Client " << old_nick << " changed nickname to: " << _nick << std::endl;
}

void CommandHandler::handleJoinCommand(int client_fd, const std::string& channel_name_raw, const std::string& password, IRCServer& server) {
    


     std::string channel_name = channel_name_raw;
    
    // Limpieza profunda: eliminar TODOS los \r y \n en todo el string
    channel_name.erase(std::remove(channel_name.begin(), channel_name.end(), '\r'), channel_name.end());
    channel_name.erase(std::remove(channel_name.begin(), channel_name.end(), '\n'), channel_name.end());
    
    // Eliminar espacios al inicio y final
    channel_name.erase(0, channel_name.find_first_not_of(" "));
    if (!channel_name.empty()) {
        channel_name.erase(channel_name.find_last_not_of(" ") + 1);
    }

    // Validación básica del nombre del canal
    if (channel_name.empty() || channel_name[0] != '#') {
        std::string err_msg = ":server 403 " + channel_name + " :Invalid channel name\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client) {
        std::cerr << "ERROR: Client not found for fd " << client_fd << std::endl;
        return;
    }


    // Verificar si el cliente está autenticado
    if (client->getStage() != CONNECTED) {
        std::string err_msg = ":server 451 " + client->getNickname() + " :You have not registered\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // Obtener el canal (puede ser NULL si no existe)
    Channel* channel = server.getChannelsBook().getChannel(channel_name);

    // Verificar contraseña solo si el canal existe y tiene contraseña
    if (channel && !channel->getPassword().empty()) {
        if (password != channel->getPassword()) {
            std::string err_msg = ":server 475 " + client->getNickname() + " " + channel_name + " :Cannot join channel (+k) - invalid password\r\n";
            safeSend(client_fd, err_msg, server);
            return;
        }
    }

    // Crear canal si no existe
    if (!channel) {
        if (!server.getChannelsBook().addChannel(channel_name)) {
            std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :Channel creation failed\r\n";
            safeSend(client_fd, err_msg, server);
            return;
        }
        channel = server.getChannelsBook().getChannel(channel_name);
        
        // Verificar que se creó correctamente
        if (!channel) {
            std::cerr << "CRITICAL ERROR: Failed to create channel " << channel_name << std::endl;
            return;
        }
    }

    // 1. Verificar si el canal es solo por invitación (modo +i)
    if (channel->isInviteOnly() && !channel->isInvited(client)) {
        std::string err_msg = ":server 473 " + client->getNickname() + " " + channel_name + " :Cannot join channel (+i)\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // 2. Verificar si el cliente ya está en el canal
    if (channel->hasClient(client)) {
        std::string msg = ":server 443 " + client->getNickname() + " " + channel_name + " :You're already in that channel\r\n";
        safeSend(client_fd, msg, server);
        return;
    }

    // 3. Verificar límite de usuarios (modo +l)
    if (channel->getUserLimit() > 0 && 
        channel->getClients().size() >= channel->getUserLimit()) {
        std::string err_msg = ":server 471 " + client->getNickname() + " " + channel_name + " :Cannot join channel (+l) - channel is full\r\n";
        safeSend(client_fd, err_msg, server);
        return;
    }

    // Primer usuario = operador
    if (channel->getClients().empty()) {
        channel->addOperator(client);
    }

    // Unirse al canal
    channel->addClient(client);
    client->joinChannel(channel_name);

    // Limpiar invitación después de unirse exitosamente
    if (channel->isInviteOnly()) {
        channel->removeInvited(client); // Necesitarás implementar este método
    }

    // Construir mensaje JOIN
    std::string join_msg = ":" + client->getNickname() + "!" + client->getRealname() + 
                          "@localhost JOIN :" + channel_name + "\r\n";
    channel->sendToAll(join_msg, NULL);

    // Enviar tema del canal o aviso de no tema
    if (!channel->getTopic().empty()) {
        std::string topic_msg = ":server 332 " + client->getNickname() + " " + channel_name + " :" + channel->getTopic() + "\r\n";
        safeSend(client_fd, topic_msg, server);
    } else {
        std::string notopic_msg = ":server 331 " + client->getNickname() + " " + channel_name + " :No topic is set\r\n";
        safeSend(client_fd, notopic_msg, server);
    }

    // Construir lista de usuarios (operadores primero)
    std::string users_list;
    const std::set<Client*>& members = channel->getClients();
    
    for (std::set<Client*>::const_iterator it = members.begin(); it != members.end(); ++it) {
        Client* member = *it;
        if (channel->isOperator(member)) {
            users_list += "@";
        }
        users_list += member->getNickname() + " ";
    }

    if (!users_list.empty()) {
        users_list.erase(users_list.size() - 1); // Eliminar último espacio
    }

    // Enviar lista de nombres
    std::string names_msg = ":server 353 " + client->getNickname() + " = " + channel_name + " :" + users_list + "\r\n";
    std::string end_msg = ":server 366 " + client->getNickname() + " " + channel_name + " :End of /NAMES list\r\n";
    safeSend(client_fd, names_msg, server);
    safeSend(client_fd, end_msg, server);
}


// ===== Archivo: ./src/Channel.cpp ===== //
#include "Channel.hpp"
#include "Client.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>



// Constructor de Channel
Channel::Channel(const std::string& name)
	: _name(name), _topic(""), _password(""), _userLimit(0), _inviteOnly(false), _topicRestricted(false) {}

// Getter para el nombre del canal
const std::string& Channel::getName() const {
	return _name;
}

// Getter y setter para el topic del canal
const std::string& Channel::getTopic() const {
	return _topic;
}

void Channel::setTopic(const std::string& topic) {
	_topic = topic;
}

// Comprobación de si el canal es solo por invitación
bool Channel::isInviteOnly() const {
	return _inviteOnly;
}

void Channel::setInviteOnly(bool val) {
	_inviteOnly = val;
}

// Comprobación de si el canal tiene restricciones en el tema
bool Channel::isTopicRestricted() const {
	return _topicRestricted;
}

void Channel::setTopicRestricted(bool val) {
	_topicRestricted = val;
}

// Getter y setter para la contraseña del canal
const std::string& Channel::getPassword() const {
  
    
	return _password;
}

void Channel::setPassword(const std::string& pass) {
	_password = pass;
}

// Getter y setter para el límite de usuarios en el canal
size_t Channel::getUserLimit() const {
	return _userLimit;
}

void Channel::setUserLimit(size_t limit) {
	_userLimit = limit;
}

// Agregar un cliente al canal
void Channel::addClient(Client* client) {
	_clients.insert(client);
}

// Eliminar un cliente del canal
void Channel::removeClient(Client* client) {
	_clients.erase(client);
    _operators.erase(client);  // También quitar de operadores si lo era
    _invited.erase(client); 
}

// Verificar si un cliente está en el canal
bool Channel::hasClient(Client* client) const {
	return _clients.find(client) != _clients.end();
}

// Agregar un operador al canal
void Channel::addOperator(Client* client) {
	_operators.insert(client);
}

// Eliminar un operador del canal
void Channel::removeOperator(Client* client) {
	_operators.erase(client);
}

// Verificar si un cliente es operador en el canal
bool Channel::isOperator(Client* client) const {
	return _operators.find(client) != _operators.end();
}

// Invitar a un cliente al canal
void Channel::inviteClient(Client* client) {
	_invited.insert(client);
}

// Verificar si un cliente ha sido invitado
bool Channel::isInvited(Client* client) const {
	return _invited.find(client) != _invited.end();
}

// Obtener la lista de clientes del canal
const std::set<Client*>& Channel::getClients() const {
	return _clients;
}

void Channel::removeInvited(Client* client) {
    _invited.erase(client);
}

// void Channel::sendToAll(const std::string& message, Client* sender)
// {
//     for (std::set<Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it) 
// 	{
//         Client* client = *it;

//         if (client == NULL)
//             continue;

//         // Si hay sender, y el cliente es el sender, lo saltamos
//         if (sender && client->getFd() == sender->getFd())
//             continue;

//         send(client->getFd(), message.c_str(), message.length(), 0);
//     }
// }
void Channel::sendToAll(const std::string& message, Client* sender)
{
    for (std::set<Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it) 
    {
        Client* client = *it;
        if (!client) 
            continue;
        if (sender && client == sender)
            continue;

        client->getOutputBuffer() += message; 
    }
}

void Channel::setMode(char mode, bool enabled, const std::string& arg) 
{
    switch (mode) {
        case 'i': _inviteOnly = enabled; break;
        case 't': _topicRestricted = enabled; break;
        case 'k': 
            if (enabled) _password = arg;
            else _password = "";
            break;
        case 'o':
            // Implementado en los métodos addOperator/removeOperator
            break;
        case 'l':
            if (enabled) _userLimit = std::atoi(arg.c_str());
            else _userLimit = 0;
            break;
    }
}

std::string Channel::getModeString() const 
{
    std::ostringstream oss;
    oss << "+";
    if (_inviteOnly) oss << "i";
    if (_topicRestricted) oss << "t";
    if (!_password.empty()) oss << "k";
    if (_userLimit > 0) oss << "l";
    return oss.str();
}


// ===== Archivo: ./src/BookClient.cpp ===== //
#include "BookClient.hpp"
#include <iostream>

bool BookClient::addClient(int fd, std::string nick, std::string user, AuthStage stage) 
{
    if (clients.find(fd) != clients.end()) return false;

    Client* new_client = NULL;
    try {
        new_client = new Client(fd, nick, user, stage);
    } 
    catch (const std::bad_alloc& e) {
        std::cerr << "Error: could not allocate memory for new Client: " << e.what() << std::endl;
        return false;
    }

    try {
        clients.insert(std::make_pair(fd, new_client));
    } 
    catch (...) {
        delete new_client;
        return false;
    }
    return true;


}


void BookClient::printbook()
{
    std::map<int, Client *>::iterator it = clients.begin();
        while(it != clients.end())
        {
            std::cout << "nick = " <<it->second->getNickname() <<  " fd = " << it->first  << std::endl;
            it ++;
        }
}

BookClient::BookClient()
{

}
BookClient::~BookClient()
{
    std::map<int, Client *>::iterator it = clients.begin();
        while(it != clients.end())
        {
            delete it->second;
            it ++;
        }
        clients.clear();

}

void BookClient::removeClient(int fd) {
    std::map<int, Client*>::iterator it = clients.find(fd);
    if (it != clients.end()) {
        delete it->second;   // Liberar memoria del Client
        clients.erase(it);   // Eliminar entrada del mapa
    }
}

bool BookClient::nickExists(const std::string& nick) 
{
    std::map<int, Client *>::iterator it = clients.begin();
    while(it != clients.end())
    {
        if (it->second->getNickname() == nick)
        {
            
            return true;
        }
        it ++;
    }
    return false;
}

Client* BookClient::getClientByNick(const std::string& nick) 
{
    std::map<int, Client*>::iterator it;
    for (it = clients.begin(); it != clients.end(); ++it) {
        if (it->second->getNickname() == nick) {
            return it->second;
        }
    }
    return NULL;
}

bool BookClient::fdExists(int fd)
{
    std::map<int, Client *>::iterator it = clients.find(fd);
    if(it != clients.end())
    {
        return true;
    }
    return false;
}

Client* BookClient::getClient(int fd) 
{
    if (clients.find(fd) != clients.end())
        return clients[fd];
    return NULL;
}

std::map<int, Client *>& BookClient::getmap() 
{
    return clients;
}



// ===== Archivo: ./src/Server.cpp ===== //
// #include "Server.hpp"
// #include "CommandHandler.hpp"
// #include <iostream>
// #include <cstdlib>
// #include <cstring>
// #include <fcntl.h> 
// #include <unistd.h>
// #include <sys/socket.h>
// #include <cerrno>
// #include <arpa/inet.h>
// #include <poll.h>
// #include <sstream>
// #include <map>
// #include <cstdio> // Necesario para perror()


#include "Server.hpp"
#include "CommandHandler.hpp"
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fcntl.h> 
#include <unistd.h>
#include <sys/socket.h>
#include <cerrno>
#include <arpa/inet.h>
#include <poll.h>
#include <sstream>
#include <map>
#include <cstdio>

// Implementación de safeSend
void IRCServer::safeSend(int client_fd, const std::string& message) {
    Client* client = clients_info.getClient(client_fd);
    if (client) {
        client->getOutputBuffer() += message;
    }
}

IRCServer::IRCServer(int port, const std::string& password) : port(port), password(password) {
    struct sockaddr_in server_addr;

    // Crear socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        std::perror("socket");
        std::exit(EXIT_FAILURE);
    }

    // SO_REUSEADDR
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        std::perror("setsockopt");
        std::exit(EXIT_FAILURE);
    }

    // Configurar dirección
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);

    // Bind
    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        std::perror("bind");
        std::exit(EXIT_FAILURE);
    }

    // Listen
    if (listen(server_fd, 10) < 0) {
        std::perror("listen");
        std::exit(EXIT_FAILURE);
    }

    // Configurar non-blocking
    if (fcntl(server_fd, F_SETFL, O_NONBLOCK) < 0) {
        std::perror("fcntl");
        std::exit(EXIT_FAILURE);
    }

    // Preparar poll
    struct pollfd pfd;
    pfd.fd = server_fd;
    pfd.events = POLLIN;
    clients.push_back(pfd);

    std::cout << "IRC Server running on port " << port << std::endl;
}

BookClient& IRCServer::getClientsBook() {
    return this->clients_info;
}

ChannelBook& IRCServer::getChannelsBook() {
    return this->channels;
}

IRCServer::~IRCServer() {
    close(server_fd);
    
    for (size_t i = 0; i < clients.size(); ++i) {
        if (clients[i].fd != server_fd) {
            close(clients[i].fd);
        }
    }
    std::cout << "Server has shut down." << std::endl;
}

void IRCServer::acceptClient() {
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    
    while (true) {
        int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);
        if (client_fd < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) break;
            std::perror("accept");
            break;
        }

        if (fcntl(client_fd, F_SETFL, O_NONBLOCK) < 0) {
            std::perror("fcntl");
            close(client_fd);
            continue;
        }

        struct pollfd pfd;
        pfd.fd = client_fd;
        pfd.events = POLLIN;
        clients.push_back(pfd);

        clients_info.addClient(client_fd, "", "", WAITING_PASSWORD);

        // Usar safeSend en lugar de send directo
        safeSend(client_fd, "Welcome to the IRC Server! Please enter the password:\n");
    }
}

void IRCServer::removeClient(int client_fd) 
{
    // ... (código existente sin cambios) ...

      Client* client = clients_info.getClient(client_fd);
    bool client_was_registered = false;
    std::string nickname = "";
    std::string realname = "";  // Añadimos para almacenar realname seguro
    
    // Paso 1: Eliminar al cliente de todos los canales donde está unido
    if (client) 
    {
        client_was_registered = true;
        nickname = client->getNickname();
        realname = client->getRealname();  // Almacenar ANTES de cualquier operación
        
        // Hacer copia de los canales porque leaveChannel modifica el set original
        std::set<std::string> joinedChannels = client->getJoinedChannels();
        
        for (std::set<std::string>::const_iterator it = joinedChannels.begin(); 
             it != joinedChannels.end(); ++it) {
            const std::string& channel_name = *it;
            Channel* channel = channels.getChannel(channel_name);
            
            // VERIFICACIÓN CRÍTICA: Asegurarnos que el canal existe
            if (channel) {
                // Construir mensaje de QUIT ANTES de modificar el cliente
                std::string quit_msg = ":" + nickname + "!~" + realname +  // Usar valor almacenado
                                      "@localhost QUIT :Connection closed\r\n";
                channel->sendToAll(quit_msg, NULL);
                
                // Eliminar al cliente del canal
                channel->removeClient(client);
                
                // Si el canal queda vacío, eliminarlo
                if (channel->getClients().empty()) {
                    channels.removeChannel(channel_name);
                }
            }
        }
    }

    // Paso 2: Cerrar conexión y eliminar de estructuras
    close(client_fd);
    
    // Eliminar de la lista de poll
    for (size_t i = 0; i < clients.size(); ++i) {
        if (clients[i].fd == client_fd) {
            clients.erase(clients.begin() + i);
            break;
        }
    }
    
    // Eliminar del libro de clientes
    clients_info.removeClient(client_fd);
    
    // Paso 3: Log
    if (client_was_registered) {
        std::cout << "Client with nickname: " << nickname
                  << " (fd: " << client_fd << ") has disconnected." << std::endl;
    } else {
        std::cout << "Unregistered client (fd: " << client_fd << ") has disconnected." << std::endl;
    }
    
}

void IRCServer::run() {
    CommandHandler handler;
    while (true) {
        if (clients.empty()) continue;

        // 1. Configurar eventos POLLOUT si hay datos pendientes
        for (size_t i = 0; i < clients.size(); ++i) {
            if (clients[i].fd != server_fd) {
                Client* client = clients_info.getClient(clients[i].fd);
                if (client && !client->getOutputBuffer().empty()) {
                    clients[i].events = POLLIN | POLLOUT;
                } else {
                    clients[i].events = POLLIN;
                }
            }
        }

        // 2. Esperar eventos
        if (poll(&clients[0], clients.size(), -1) < 0) {
            std::perror("poll");
            continue;
        }

        // 3. Manejar eventos
        for (int i = static_cast<int>(clients.size()) - 1; i >= 0; --i) {
            // Manejar errores/desconexiones primero
            if (clients[i].revents & (POLLERR | POLLHUP)) {
                removeClient(clients[i].fd);
                continue;
            }
            
            // Eventos de lectura
            if (clients[i].revents & POLLIN) {
                if (clients[i].fd == server_fd) {
                    acceptClient();
                } else {
                    handleClientData(clients[i].fd, handler);
                }
            }
            
            // Eventos de escritura
            if (clients[i].revents & POLLOUT) {
                Client* client = clients_info.getClient(clients[i].fd);
                if (client) {
                    std::string& output = client->getOutputBuffer();
                    if (!output.empty()) {
                        ssize_t sent = send(clients[i].fd, output.c_str(), output.size(), MSG_DONTWAIT);
                        if (sent > 0) {
                            output.erase(0, sent);
                        }
                    }
                }
            }
        }
    }
}


void IRCServer::handleClientData(int client_fd, CommandHandler &handler) {
    char buffer[512];
    memset(buffer, 0, sizeof(buffer));
    int bytes_received = recv(client_fd, buffer, sizeof(buffer) - 1, 0);

    if (bytes_received < 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK)
            return;  // No hay datos ahora
        std::perror("recv handleClientData");
        removeClient(client_fd);
        return;
    }
    if (bytes_received == 0) {
        removeClient(client_fd);
        return;
    }

    buffer[bytes_received] = '\0';
    Client* client = clients_info.getClient(client_fd);
    if (!client) return;

    // ========= PROTECCIÓN CONTRA DoS ========= //
    // Verificar si el nuevo dato excede el límite del buffer
    if (client->getBuffer().size() + bytes_received > Client::MAX_BUFFER_SIZE) {
        std::cerr << "Client fd " << client_fd << " exceeded buffer limit (" 
                  << Client::MAX_BUFFER_SIZE << " bytes). Disconnecting." << std::endl;
        removeClient(client_fd);
        return;
    }
    
    // Añadir datos al buffer
    client->getBuffer() += buffer;
    
    // Procesar líneas completas
    size_t pos;
    while ((pos = client->getBuffer().find('\n')) != std::string::npos) {
        std::string line = client->getBuffer().substr(0, pos);
        client->getBuffer().erase(0, pos + 1);
        line.erase(line.find_last_not_of("\r\n") + 1);

        if (client->getStage() == WAITING_PASSWORD) {
            if (line != password) {
                // CAMBIO: send -> safeSend
                safeSend(client_fd, "Incorrect password. Connection closed.\n");
                removeClient(client_fd);
                return;
            }
            client->setStage(WAITING_NICKNAME);
            // CAMBIO: send -> safeSend
            safeSend(client_fd, "Please enter your nickname:\n");
            return;
        }
        else if (client->getStage() == WAITING_NICKNAME) {
            line.erase(0, line.find_first_not_of(" "));
            line.erase(line.find_last_not_of(" ") + 1);
            if (line.empty() || clients_info.nickExists(line)) {
                // CAMBIO: send -> safeSend
                safeSend(client_fd, "Nickname invalid or taken. Try again:\n");
                return;
            }
            client->setNickname(line);
            client->setStage(WAITING_USERNAME);
            // CAMBIO: send -> safeSend
            safeSend(client_fd, "Please enter your real name:\n");
            return;
        }
        else if (client->getStage() == WAITING_USERNAME) {
            line.erase(0, line.find_first_not_of(" "));
            line.erase(line.find_last_not_of(" ") + 1);
            if (line.empty() ) {
                // CAMBIO: send -> safeSend
                safeSend(client_fd, "Empty username. Try again:\n");
                return;
            }
            client->setRealname(line);
            client->setStage(CONNECTED);
            // Mantengo tu mensaje original con fd
            std::cout << "New client " << line << " connected with fd " << client_fd << ".\n";
            // CAMBIO: send -> safeSend
            safeSend(client_fd, "You have successfully authenticated and joined the server.\n");
            return;
        }
        else if (client->getStage() == CONNECTED) {
            // MANTENGO TODO TU FORMATO COLORIDO ORIGINAL
            std::string sender_nick = client->getNickname();
            std::string full_message = "[Message from: " + sender_nick + "]: " + line + "\n";

            std::cout << "--------------------------------------------\n";
            std::cout << "[Message from: \033[1;34m" << sender_nick << "\033[0m]\n";
            std::cout << "--------------------------------------------\n";
            std::cout << "\033[1;32m" << line << "\033[0m\n";
            std::cout << "--------------------------------------------\n";

            handler.handleClientMessage(client_fd, line, *this);
        }
    }

    // Verificación adicional para datos residuales sin \n
    if (client->getBuffer().size() > Client::MAX_BUFFER_SIZE) {
        // Mantengo tu mensaje de error detallado original
        std::cerr << "Client fd " << client_fd << " buffer overflow (" 
                  << client->getBuffer().size() << " > " 
                  << Client::MAX_BUFFER_SIZE << "). Disconnecting." << std::endl;
        removeClient(client_fd);
        return;
    }
}


// ===== Archivo: ./src/main.cpp ===== //
#include "Server.hpp"
#include <cstdlib>
#include <iostream>

int main(int argc, char* argv[]) {
     if (argc != 3) {
        std::cerr << "Usage: ./ircserv <port> <password>" << std::endl;
        return 1;
    }

    // Verificar que el puerto sea numérico
    for (char* p = argv[1]; *p; p++) {
        if (!std::isdigit(*p)) {
            std::cerr << "Invalid port: must be numeric" << std::endl;
            return 1;
        }
    }

    int port = std::atoi(argv[1]);
    if (port <= 0 || port > 65535) {
        std::cerr << "Invalid port number. Port must be between 1 and 65535." << std::endl;
        return 1;
    }

    std::string password = argv[2];
    if (password.empty()) {
        std::cerr << "Password cannot be empty." << std::endl;
        return 1;
    }

    IRCServer server(port, password);
    server.run();
    return 0;
}



// ===== Archivo: ./src/Client.cpp ===== //
#include "Client.hpp"

Client::Client() : fd(-1), nickname(""), realname("") {}

// Client::Client(int fd, std::string _nick) : fd(fd), nickname(_nick), realname("") {}

Client::Client(int fd, std::string _nick, std::string _user, AuthStage stage )
    : fd(fd), nickname(_nick), realname(_user),buffer(""), stage(stage) {}

std::string& Client::getBuffer() 
{ 
    return buffer; 
}

int Client::getFd() const {
    return fd;
}

void Client::setFd(int _fd) {
    fd = _fd;
}

std::string Client::getNickname() const {
    return nickname;
}

void Client::setNickname(const std::string& nick) {
    nickname = nick;
}

std::string Client::getRealname() const {
    return realname;
}

void Client::setRealname(const std::string& name) {
    realname = name;
}


AuthStage Client::getStage() const 
{ 
    return stage; 
}

void Client::setStage(AuthStage s) 
{ 
    stage = s; 
}

void Client::joinChannel(const std::string& channelName) {
    joinedChannels.insert(channelName);
}

void Client::leaveChannel(const std::string& channelName) {
    joinedChannels.erase(channelName);
}

bool Client::isInChannel(const std::string& channelName) const {
    return joinedChannels.find(channelName) != joinedChannels.end();
}

const std::set<std::string>& Client::getJoinedChannels() const {
    return joinedChannels;
}

std::string& Client::getOutputBuffer() 
{ 
    return output_buffer; 
}

void Client::safeSend(const std::string& message) {
    output_buffer += message;
}



NAME = ircserv
CC = c++
CFLAGS = -Wall -Wextra -Werror -std=c++98 -Ilib
DEBUG_FLAGS = -g  # Agrega la flag de depuración

SRC_DIR = src
OBJ_DIR = obj
SRC = $(wildcard $(SRC_DIR)/*.cpp)
OBJ = $(patsubst $(SRC_DIR)/%.cpp, $(OBJ_DIR)/%.o, $(SRC))

# Variable que indica si estamos en modo de depuración
DEBUG = 0

# Si DEBUG está activado, añadimos las flags de depuración
ifeq ($(DEBUG), 1)
    CFLAGS += $(DEBUG_FLAGS)
endif

all: $(NAME)

$(NAME): $(OBJ)
	$(CC) $(CFLAGS) -o $(NAME) $(OBJ)

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJ_DIR):
	mkdir -p $(OBJ_DIR)

clean:
	rm -rf $(OBJ_DIR)

fclean: clean
	rm -f $(NAME)

re: fclean all

# Modo de depuración
debug: DEBUG = 1
debug: re

.PHONY: all clean fclean re debug
// ===== Archivo: ./lib/Server.hpp ===== //
#ifndef IRC_SERVER_HPP
#define IRC_SERVER_HPP

#include <string>
#include <vector>
#include <poll.h>
#include "CommandHandler.hpp"
#include "BookClient.hpp"  // Incluimos la clase Book
#include "ChannelBook.hpp"

class CommandHandler;
// Definición de la clase IRCServer
class IRCServer {
    private:
        // Atributos del servidor
        int server_fd;  // Descriptor de archivo para el socket del servidor
        int port;       // Puerto en el que el servidor escucha
        std::string password;  // Contraseña del servidor
        std::vector<struct pollfd> clients;  // Lista de clientes conectados
        BookClient clients_info;  // Usamos Book para almacenar la información de los clientes
        ChannelBook channels;
    
public:
    // Constructor y Destructor
    IRCServer(int port, const std::string& password);
    ~IRCServer();

    // Métodos para manejar clientes y mensajes
    void acceptClient();
    void removeClient(int client_fd);
    void handleClientData(int client_fd, CommandHandler& handler);
    void run();

    // Métodos de interacción con clientes
    int nickExist(std::string _nick);

    BookClient&  getClientsBook();
    ChannelBook&  getChannelsBook();


    // Métodos para obtener y configurar información de clientes

};

#endif  // IRC_SERVER_HPP



// ===== Archivo: ./lib/BookClient.hpp ===== //
#ifndef BOOK_CLIENT_HPP
#define BOOK_CLIENT_HPP

#include <map>
#include "Client.hpp"

class BookClient 
{
    private:
        std::map<int, Client *> clients;

    public:
        BookClient();
        ~BookClient();
        bool addClient(int fd, std::string nick, std::string user, AuthStage stage) ;
        void    removeClient(int fd);
        bool    nickExists(const std::string& nick);
        bool    fdExists(int fd);

        Client* getClientByNick(const std::string& nick);
        Client* getClient(int fd);
        std::map<int, Client *>&    getmap();
        void printbook();
};

#endif



// ===== Archivo: ./lib/ChannelBook.hpp ===== //
#ifndef CHANNELBOOK_HPP
#define CHANNELBOOK_HPP

#include <map>
#include <string>
#include "Channel.hpp"

class ChannelBook {
    
    private:
        std::map<std::string, Channel*> _channels;
public:
    ~ChannelBook();
    Channel* getChannel(const std::string& name);
    bool addChannel(const std::string& name);
    void removeChannel(const std::string& name);
    bool channelExists(const std::string& name) const;
    std::map<std::string, Channel*>& getAllChannels();
};

#endif



// ===== Archivo: ./lib/Client.hpp ===== //
#ifndef CLIENT_HPP
#define CLIENT_HPP

#include <string>
#include <set>

enum AuthStage 
{
    WAITING_PASSWORD,
    WAITING_NICKNAME,
    WAITING_USERNAME,
    CONNECTED
};

class Client {
private:
    int fd;
    // static const size_t MAX_BUFFER_SIZE = 10240; // 10KB
    std::string nickname;
    std::string realname;
    std::string buffer;
    AuthStage stage;
    std::set<std::string> joinedChannels;

public:
    static const size_t MAX_BUFFER_SIZE = 10240;
    Client();
    Client(int fd, std::string _nick,std::string _user,  AuthStage _stage = WAITING_PASSWORD);

    int getFd() const;
    void setFd(int _fd);

    AuthStage getStage() const ;
    void setStage(AuthStage s) ;

    std::string getNickname() const;
    void setNickname(const std::string& nick);

    std::string getRealname() const;
    void setRealname(const std::string& name);

    std::string& getBuffer();

    void joinChannel(const std::string& channelName);
    void leaveChannel(const std::string& channelName);
    bool isInChannel(const std::string& channelName) const;
    const std::set<std::string>& getJoinedChannels() const;

};

#endif



// ===== Archivo: ./lib/Channel.hpp ===== //

// Channel.hpp
#ifndef CHANNEL_HPP
#define CHANNEL_HPP

#include <string>
#include <map>
#include <set>
#include <vector>
#include <sys/socket.h> 

class Client; // forward declaration

class Channel {
private:
	std::string _name;
	std::string _topic;
	std::string _password;
	size_t      _userLimit;
	bool        _inviteOnly;
	bool        _topicRestricted;

	std::set<Client*> _clients;
	std::set<Client*> _operators;
	std::set<Client*> _invited;

public:
	Channel(const std::string& name);

	// Getters y setters
	const std::string& getName() const;
	const std::string& getTopic() const;
	void setTopic(const std::string& topic);

	bool isInviteOnly() const;
	void setInviteOnly(bool val);

	bool isTopicRestricted() const;
	void setTopicRestricted(bool val);

	const std::string& getPassword() const;
	void setPassword(const std::string& pass);

	size_t getUserLimit() const;
	void setUserLimit(size_t limit);

	// Gestión de usuarios
	void addClient(Client* client);
	void removeClient(Client* client);
	bool hasClient(Client* client) const;

	// Operadores
	void addOperator(Client* client);
	void removeOperator(Client* client);
	bool isOperator(Client* client) const;

	// Invitados
	void inviteClient(Client* client);
	bool isInvited(Client* client) const;
 	void removeInvited(Client* client);
	
	const std::set<Client*>& getClients() const;

	void sendToAll(const std::string& message, Client* sender);

	//Mode
	void setMode(char mode, bool enabled, const std::string& arg = "");
	std::string getModeString() const;
};

#endif



// ===== Archivo: ./lib/CommandHandler.hpp ===== //
#ifndef COMMAND_HANDLER_HPP
#define COMMAND_HANDLER_HPP

#include <string>
#include <vector>
#include "Server.hpp"

class IRCServer;

class CommandHandler {
public:
    struct ParsedMessage {
        std::string command;
        std::vector<std::string> params;
        std::string trailing;
    };

    CommandHandler();
    ~CommandHandler();

    static ParsedMessage parseMessage(const std::string& raw_message);
    void handleClientMessage(int client_fd, const std::string& message, IRCServer& server);

    // Métodos de comandos
    void handleNickCommand(int client_fd, const std::string& new_nick, IRCServer& server);
    void handlePrivMsgCommand(int client_fd, const std::string& target, const std::string& message, IRCServer& server);
    void handlePartCommand(int client_fd, const std::string& channel_name, const std::string& reason, IRCServer& server);
    void handleJoinCommand(int client_fd, const std::string& channel_name_raw,const std::string& password, IRCServer& server);
    void sendToAllClients(const std::string& message, int sender_fd, IRCServer& server);
    void handleModeCommand(int client_fd, const std::string& target, const std::string& mode_str, const std::vector<std::string>& args,IRCServer& server) ;
    void handleKickCommand(int client_fd, const std::string& channel_name, const std::string& user, const std::string& reason, IRCServer& server);
    void handleInviteCommand(int client_fd, const std::string& nick, const std::string& channel_name, IRCServer& server);
    void handleTopicCommand(int client_fd, const std::string& channel_name, const std::string& new_topic, IRCServer& server); 
private:
    // Helper para enviar errores
    void sendError(int client_fd, const std::string& code, const std::string& msg);
};

#endif



// #ifndef COMMAND_HANDLER_HPP
// #define COMMAND_HANDLER_HPP

// #include <string>
// #include "Server.hpp"

// class IRCServer;
// class CommandHandler {

// public:
//     CommandHandler();
//     ~CommandHandler();

//     void handleNickCommand(int client_fd, const std::string& new_nick, IRCServer& server);
//     void handleClientMessage(int client_fd, const std::string& message, IRCServer& server);
//     void sendToAllClients(const std::string& message, int sender_fd, IRCServer& server);
//     //void handlePrivMsgCommand(int client_fd, const std::string& target, const std::string& message, IRCServer& server);
//     void handlePrivMsgCommand(int client_fd, const std::string& params, IRCServer& server);
//     void handlePartCommand(int client_fd, const std::string& channel_name, const std::string& reason, IRCServer& server);
//     void handleJoinCommand(int client_fd, const std::string& channel_name_raw, IRCServer& server);
// };

// #endif



// ===== Archivo: ./src/ChannelBook.cpp ===== //
#include "ChannelBook.hpp"
#include <iostream>

Channel* ChannelBook::getChannel(const std::string& name) {
    if (_channels.find(name) != _channels.end())
        return _channels[name];
    return NULL;
}

ChannelBook::~ChannelBook() {
    for (std::map<std::string, Channel*>::iterator it = _channels.begin(); it != _channels.end(); ++it) {
        delete it->second;
    }
}

bool ChannelBook::addChannel(const std::string& name) 
{
    if (_channels.find(name) != _channels.end()) return true;

    Channel* new_channel = NULL;
    try {
        new_channel = new Channel(name);
    } 
    catch (const std::bad_alloc& e) { 
        std::cerr << "Error: could not allocate memory for new Channel: " << e.what() << std::endl;

        return false;
    }

    try {
        _channels.insert(std::make_pair(name, new_channel));
    } 
    catch (...) {
        delete new_channel;
        return false;
    }
    return true;

}

void ChannelBook::removeChannel(const std::string& name) {
    std::map<std::string, Channel*>::iterator it = _channels.find(name);
    if (it != _channels.end()) {
        delete it->second;
        _channels.erase(it);
    }
}

bool ChannelBook::channelExists(const std::string& name) const {
    return _channels.find(name) != _channels.end();
}

std::map<std::string, Channel*>& ChannelBook::getAllChannels() {
    return _channels;
}




// ===== Archivo: ./src/CommandHandler.cpp ===== //
#include "CommandHandler.hpp"
#include <sstream>
#include <iostream>
#include <sys/socket.h>
#include <unistd.h>
#include <algorithm>  
#include "CommandHandler.hpp"
#include <cstring>
#include <cctype> 
#include "CommandHandler.hpp"
#include <cstdlib>
#include <map>

CommandHandler::CommandHandler()
{

}
CommandHandler::~CommandHandler()
{

}

void CommandHandler::sendError(int client_fd, const std::string& code, const std::string& msg)
{
    std::string msg_error = "code error: " + code +" " + msg;
    send(client_fd, msg_error.c_str(), msg_error.length(), 0);
}

CommandHandler::ParsedMessage CommandHandler::parseMessage(const std::string& raw_message) {
    ParsedMessage result;
    
    // 1. Limitar tamaño máximo según RFC 1459 (512 bytes)
    if (raw_message.size() > 512) {
        result.command = "ERROR";
        result.trailing = "Message too long";
        return result;
    }
    
    // 2. Filtrar caracteres no ASCII y secuencias de escape
    std::string cleaned_message;
    for (size_t i = 0; i < raw_message.size(); ++i) {
        const char c = raw_message[i];
        // Permitir caracteres ASCII imprimibles (32-126) y \r, \n
        if ((c >= 32 && c <= 126) || c == '\r' || c == '\n' || c == '\t') {
            cleaned_message += c;
        }
        // Convertir secuencias de escape a espacios
        else if (c == 27) {  // ESC character (inicio de secuencia ANSI)
            while (i + 1 < raw_message.size() && 
                  (raw_message[i+1] == '[' || 
                   (raw_message[i+1] >= 'A' && raw_message[i+1] <= 'Z') || 
                   (raw_message[i+1] >= 'a' && raw_message[i+1] <= 'z'))) {
                i++;
            }
            cleaned_message += ' ';  // Reemplazar secuencia por espacio
        }
    }
    
    std::istringstream iss(cleaned_message);
    std::string token;
    
    // 3. Parsear comando principal
    if (!(iss >> result.command)) {
        result.command = "EMPTY";
        return result;
    }
    
    // 4. Parsear parámetros y trailing con límite máximo
    int param_count = 0;
    const int MAX_PARAMS = 10;
    
    while (iss >> token && param_count < MAX_PARAMS) {
        if (token[0] == ':') {
            // CORRECCIÓN: Capturar trailing completo incluyendo espacios
            result.trailing = token.substr(1);  // Quitar el ':' inicial
            
            // Leer el resto de la línea incluyendo espacios
            std::string remainder;
            std::getline(iss, remainder);
            
            // Añadir el resto si hay más contenido
            if (!remainder.empty()) {
                // Eliminar espacio inicial si existe
                if (!remainder.empty() && remainder[0] == ' ') {
                    remainder = remainder.substr(1);
                }
                result.trailing += " " + remainder;
            }
            
            // Eliminar \r y \n del final
            size_t end = result.trailing.find_last_not_of("\r\n");
            if (end != std::string::npos) {
                result.trailing = result.trailing.substr(0, end + 1);
            }
            break;
        }
        
        // Limitar tamaño de cada parámetro
        if (token.size() > 50) {
            token = token.substr(0, 50);
        }
        
        result.params.push_back(token);
        param_count++;
    }
    
    // 5. Limitar tamaño del trailing
    if (result.trailing.size() > 300) {
        result.trailing = result.trailing.substr(0, 300);
    }
    
    return result;
}

// CommandHandler::ParsedMessage CommandHandler::parseMessage(const std::string& raw_message) {
//     ParsedMessage result;
    
//     // 1. Limitar tamaño máximo según RFC 1459 (512 bytes)
//     if (raw_message.size() > 512) {
//         result.command = "ERROR";
//         result.trailing = "Message too long";
//         return result;
//     }
    
//     // 2. Filtrar caracteres no ASCII y secuencias de escape
//     std::string cleaned_message;
//     for (size_t i = 0; i < raw_message.size(); ++i) {
//         const char c = raw_message[i];
//         // Permitir caracteres ASCII imprimibles (32-126) y \r, \n
//         if ((c >= 32 && c <= 126) || c == '\r' || c == '\n' || c == '\t') {
//             cleaned_message += c;
//         }
//         // Convertir secuencias de escape a espacios
//         else if (c == 27) {  // ESC character (inicio de secuencia ANSI)
//             while (i + 1 < raw_message.size() && 
//                   (raw_message[i+1] == '[' || 
//                    (raw_message[i+1] >= 'A' && raw_message[i+1] <= 'Z') || 
//                    (raw_message[i+1] >= 'a' && raw_message[i+1] <= 'z'))) {
//                 i++;
//             }
//             cleaned_message += ' ';  // Reemplazar secuencia por espacio
//         }
//     }
    
//     std::istringstream iss(cleaned_message);
//     std::string token;
    
//     // 3. Parsear comando principal
//     if (!(iss >> result.command)) {
//         result.command = "EMPTY";
//         return result;
//     }
    
//     // 4. Parsear parámetros y trailing con límite máximo
//     int param_count = 0;
//     const int MAX_PARAMS = 10;
    
//     while (iss >> token && param_count < MAX_PARAMS) {
//         if (token[0] == ':') {
//             // Capturar trailing completo
//             result.trailing = token.substr(1);
//             std::getline(iss, result.trailing, '\0');  // Leer hasta final
            
//             // Eliminar \r y \n del final
//             size_t end = result.trailing.find_last_not_of("\r\n");
//             if (end != std::string::npos) {
//                 result.trailing = result.trailing.substr(0, end + 1);
//             }
//             break;
//         }
        
//         // Limitar tamaño de cada parámetro
//         if (token.size() > 50) {
//             token = token.substr(0, 50);
//         }
        
//         result.params.push_back(token);
//         param_count++;
//     }
    
//     // 5. Limitar tamaño del trailing
//     if (result.trailing.size() > 300) {
//         result.trailing = result.trailing.substr(0, 300);
//     }
    
//     return result;
// }


// CommandHandler::ParsedMessage CommandHandler::parseMessage(const std::string& raw_message) {
//     ParsedMessage result;
//     std::istringstream iss(raw_message);
//     std::string token;
    
//     iss >> result.command;
    
//     while (iss >> token) {
//         if (token[0] == ':') {
//             result.trailing = token.substr(1);
//             std::getline(iss, result.trailing);
//             // Limpiar retornos de carro
//             size_t end = result.trailing.find_last_not_of("\r\n");
//             if (end != std::string::npos) {
//                 result.trailing = result.trailing.substr(0, end + 1);
//             }
//             break;
//         }
//         result.params.push_back(token);
//     }
    
//     return result;
// }
// CommandHandler::ParsedMessage CommandHandler::parseMessage(const std::string& raw_message) 
// {
//     ParsedMessage result;
//     std::istringstream iss(raw_message);
//     std::string token;
    
//     iss >> result.command;  // Extraer comando principal
    
//     // Procesar parámetros y trailing
//     while (iss >> token) {
//         if (token[0] == ':') {  // Inicio del trailing
//             result.trailing = token.substr(1);
//             std::getline(iss, result.trailing);  // Capturar todo lo restante
//             break;
//         }
//         result.params.push_back(token);
//     }
    
//     // Limpiar trailing (eliminar \r\n)
//     if (!result.trailing.empty()) {
//         size_t end = result.trailing.find_last_not_of("\r\n");
//         if (end != std::string::npos) {
//             result.trailing = result.trailing.substr(0, end + 1);
//         }
//     }
    
//     return result;
// }

// Modificar handleClientMessage para usar el parser
std::string cleanInput(const std::string& input) 
{
    std::string cleaned;
    for (size_t i = 0; i < input.size(); ++i) {
        const char c = input[i];
        if (c >= 32 && c <= 126) { // Solo caracteres ASCII imprimibles
            cleaned += c;
        }
    }
    return cleaned;
}


void CommandHandler::handleClientMessage(int client_fd, const std::string& message, IRCServer& server) {
    std::string cleaned_msg = cleanInput(message);
    ParsedMessage parsed = parseMessage(cleaned_msg);

    if (parsed.command == "NICK") {
        handleNickCommand(client_fd, parsed.params.empty() ? "" : parsed.params[0], server);
    } 
    else if (parsed.command == "QUIT") {
        server.removeClient(client_fd);
    } 
    else if (parsed.command == "JOIN") {
        std::string channel = parsed.params.empty() ? "" : parsed.params[0];
        std::string password = parsed.params.size() > 1 ? parsed.params[1] : "";
        handleJoinCommand(client_fd, parsed.params.empty() ? "" : parsed.params[0], password, server);
    } 
    else if (parsed.command == "PRIVMSG") {
        if (parsed.params.empty() || parsed.trailing.empty()) {
            sendError(client_fd, "411", "PRIVMSG :Not enough parameters");
            return;
        }
        handlePrivMsgCommand(client_fd, parsed.params[0], parsed.trailing, server);
    } 
    else if (parsed.command == "PART") {
        handlePartCommand(client_fd, parsed.params.empty() ? "" : parsed.params[0], parsed.trailing, server);
    }
    else if (parsed.command == "MODE") {
        // Verificación robusta de parámetros
        if (parsed.params.empty()) {
            sendError(client_fd, "461", "MODE :Not enough parameters");
            return;
        }
        
        const std::string& target = parsed.params[0];
        std::string modes = "";
        std::vector<std::string> args;
        
        // Manejo eficiente de modos y argumentos
        if (parsed.params.size() > 1) {
            modes = parsed.params[1];
            
            // Copia directa de argumentos sin creación temporal
            if (parsed.params.size() > 2) {
                args.reserve(parsed.params.size() - 2);  // Optimización de memoria
                for (size_t i = 2; i < parsed.params.size(); ++i) {
                    args.push_back(parsed.params[i]);
                }
            }
        }
    
        handleModeCommand(client_fd, target, modes, args, server);
    }
    else if (parsed.command == "INVITE") {
        if (parsed.params.size() < 2) {
            sendError(client_fd, "461", "INVITE :Not enough parameters");
            return;
        }
        handleInviteCommand(client_fd, parsed.params[0], parsed.params[1], server);
    }
    else if (parsed.command == "KICK") {
        std::string channel = parsed.params.size() > 0 ? parsed.params[0] : "";
        std::string user = parsed.params.size() > 1 ? parsed.params[1] : "";
        std::string reason = parsed.trailing;
        handleKickCommand(client_fd, channel, user, reason, server);
    }
    else if (parsed.command == "TOPIC") {
        std::string channel = parsed.params.empty() ? "" : parsed.params[0];
        std::string new_topic = parsed.trailing;
        handleTopicCommand(client_fd, channel, new_topic, server);
    }

}

// void CommandHandler::handleNickCommand(int client_fd, const std::string& new_nick, IRCServer &server ) 
// {
//     std::string _nick(new_nick);

//    std::cout << "handle nick command" << std::endl;
//    _nick.erase(_nick.find_last_not_of("\r\n") + 1);  
//    _nick.erase(0, _nick.find_first_not_of(" ")); 
//    _nick.erase(_nick.find_last_not_of(" ") + 1); 

//     if (_nick.empty()) 
//     {
//         std::string error_msg = "ERROR: Nickname cannot be empty.\n";
//         send(client_fd, error_msg.c_str(), error_msg.length(), 0);
//         return;
//     }

//     if(server.getClientsBook().nickExists(_nick))
//     {
//             std::string error_msg = "ERROR: Nickname already in use.\n";
//             send(client_fd, error_msg.c_str(), error_msg.length(), 0);
//             return;
//     }

//     if (!server.getClientsBook().fdExists(client_fd) ) 
//     {
//         std::cout << "NO EXISTE FD" << std::endl;
//         std::cerr << "ERROR: No client found with fd " << client_fd << std::endl;
//         return;
//     }
//     Client* client = server.getClientsBook().getClient(client_fd);
//     if (!client) 
//     {
//         std::cerr << "ERROR: Client pointer is NULL for fd " << client_fd << std::endl;
//         return;
//     }
//     client->setNickname(_nick);
//     // Establecer el nuevo nickname
//     std::string success_msg = "Nickname successfully set to: " + _nick + "\n";
//     send(client_fd, success_msg.c_str(), success_msg.length(), 0);
//     std::cout << "Client with fd " << client_fd << " has changed their nickname to: " << _nick << "." << std::endl;
// }



// void CommandHandler::handleNickCommand(int client_fd, const std::string& new_nick, IRCServer &server) 
// {
//     std::string _nick(new_nick);

//     // Limpiar el nuevo nick
//     _nick.erase(_nick.find_last_not_of("\r\n") + 1);  
//     _nick.erase(0, _nick.find_first_not_of(" ")); 
//     _nick.erase(_nick.find_last_not_of(" ") + 1); 

//     if (_nick.empty()) 
//     {
//         std::string error_msg = "ERROR: Nickname cannot be empty.\n";
//         send(client_fd, error_msg.c_str(), error_msg.length(), 0);
//         return;
//     }

//     if(server.getClientsBook().nickExists(_nick))
//     {
//         std::string error_msg = "ERROR: Nickname already in use.\n";
//         send(client_fd, error_msg.c_str(), error_msg.length(), 0);
//         return;
//     }

//     Client* client = server.getClientsBook().getClient(client_fd);
//     if (!client) 
//     {
//         std::cerr << "ERROR: Client pointer is NULL for fd " << client_fd << std::endl;
//         return;
//     }
    
//     // Guardar el nick antiguo para notificación
//     std::string old_nick = client->getNickname();
    
//     // Actualizar el nickname
//     client->setNickname(_nick);
    
//     // Notificar al cliente que cambió su nick
//     std::string success_msg = ":" + old_nick + " NICK :" + _nick + "\r\n";
//     send(client_fd, success_msg.c_str(), success_msg.length(), 0);
    
//     // Notificar a todos los canales donde está presente
//     const std::set<std::string>& joinedChannels = client->getJoinedChannels();
//     for (std::set<std::string>::const_iterator it = joinedChannels.begin(); it != joinedChannels.end(); ++it) 
//     {
//         Channel* channel = server.getChannelsBook().getChannel(*it);
//         if (channel) 
//         {
//             // Construir mensaje en formato IRC estándar
//             std::string msg = ":" + old_nick + "!" + client->getRealname() + 
//                              "@localhost NICK :" + _nick + "\r\n";
//             channel->sendToAll(msg, client);
//         }
//     }
    
//     std::cout << "Client " << old_nick << " changed nickname to: " << _nick << std::endl;
// }

void CommandHandler::handleNickCommand(int client_fd, const std::string& new_nick, IRCServer &server) 
{
    std::string _nick(new_nick);

    // Limpiar el nuevo nick
    _nick.erase(_nick.find_last_not_of("\r\n") + 1);  
    _nick.erase(0, _nick.find_first_not_of(" ")); 
    _nick.erase(_nick.find_last_not_of(" ") + 1); 

    if (_nick.empty()) 
    {
        std::string error_msg = "ERROR: Nickname cannot be empty.\n";
        send(client_fd, error_msg.c_str(), error_msg.length(), 0);
        return;
    }

    if(server.getClientsBook().nickExists(_nick))
    {
        std::string error_msg = "ERROR: Nickname already in use.\n";
        send(client_fd, error_msg.c_str(), error_msg.length(), 0);
        return;
    }

    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client) 
    {
        std::cerr << "ERROR: Client pointer is NULL for fd " << client_fd << std::endl;
        return;
    }
    
    // Guardar el nick antiguo para notificación
    std::string old_nick = client->getNickname();
    
    // Actualizar el nickname
    client->setNickname(_nick);
    
    // Notificar al cliente que cambió su nick
    std::string success_msg = ":" + old_nick + " NICK :" + _nick + "\r\n";
    send(client_fd, success_msg.c_str(), success_msg.length(), 0);
    
    // Notificar a todos los canales donde está presente
    const std::set<std::string>& joinedChannels = client->getJoinedChannels();
    for (std::set<std::string>::const_iterator it = joinedChannels.begin(); it != joinedChannels.end(); ++it) 
    {
        Channel* channel = server.getChannelsBook().getChannel(*it);
        if (channel) 
        {
            // Construir mensaje en formato IRC estándar
            std::string msg = ":" + old_nick + "!" + client->getRealname() + 
                             "@localhost NICK :" + _nick + "\r\n";
            channel->sendToAll(msg, client);
        }
    }
    
    std::cout << "Client " << old_nick << " changed nickname to: " << _nick << std::endl;
}

void CommandHandler::handleJoinCommand(int client_fd, const std::string& channel_name_raw, const std::string& password, IRCServer& server) {
    


     std::string channel_name = channel_name_raw;
    
    // Limpieza profunda: eliminar TODOS los \r y \n en todo el string
    channel_name.erase(std::remove(channel_name.begin(), channel_name.end(), '\r'), channel_name.end());
    channel_name.erase(std::remove(channel_name.begin(), channel_name.end(), '\n'), channel_name.end());
    
    // Eliminar espacios al inicio y final
    channel_name.erase(0, channel_name.find_first_not_of(" "));
    if (!channel_name.empty()) {
        channel_name.erase(channel_name.find_last_not_of(" ") + 1);
    }

    // Validación básica del nombre del canal
    if (channel_name.empty() || channel_name[0] != '#') {
        std::string err_msg = ":server 403 " + channel_name + " :Invalid channel name\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client) {
        std::cerr << "ERROR: Client not found for fd " << client_fd << std::endl;
        return;
    }


    // Verificar si el cliente está autenticado
    if (client->getStage() != CONNECTED) {
        std::string err_msg = ":server 451 " + client->getNickname() + " :You have not registered\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // Obtener el canal (puede ser NULL si no existe)
    Channel* channel = server.getChannelsBook().getChannel(channel_name);

    // Verificar contraseña solo si el canal existe y tiene contraseña
    if (channel && !channel->getPassword().empty()) {
        if (password != channel->getPassword()) {
            std::string err_msg = ":server 475 " + client->getNickname() + " " + channel_name + " :Cannot join channel (+k) - invalid password\r\n";
            send(client_fd, err_msg.c_str(), err_msg.size(), 0);
            return;
        }
    }

    // Crear canal si no existe
    if (!channel) {
        if (!server.getChannelsBook().addChannel(channel_name)) {
            std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :Channel creation failed\r\n";
            send(client_fd, err_msg.c_str(), err_msg.size(), 0);
            return;
        }
        channel = server.getChannelsBook().getChannel(channel_name);
        
        // Verificar que se creó correctamente
        if (!channel) {
            std::cerr << "CRITICAL ERROR: Failed to create channel " << channel_name << std::endl;
            return;
        }
    }

    // 1. Verificar si el canal es solo por invitación (modo +i)
    if (channel->isInviteOnly() && !channel->isInvited(client)) {
        std::string err_msg = ":server 473 " + client->getNickname() + " " + channel_name + " :Cannot join channel (+i)\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // 2. Verificar si el cliente ya está en el canal
    if (channel->hasClient(client)) {
        std::string msg = ":server 443 " + client->getNickname() + " " + channel_name + " :You're already in that channel\r\n";
        send(client_fd, msg.c_str(), msg.size(), 0);
        return;
    }

    // 3. Verificar límite de usuarios (modo +l)
    if (channel->getUserLimit() > 0 && 
        channel->getClients().size() >= channel->getUserLimit()) {
        std::string err_msg = ":server 471 " + client->getNickname() + " " + channel_name + " :Cannot join channel (+l) - channel is full\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // Primer usuario = operador
    if (channel->getClients().empty()) {
        channel->addOperator(client);
    }

    // Unirse al canal
    channel->addClient(client);
    client->joinChannel(channel_name);

    // Limpiar invitación después de unirse exitosamente
    if (channel->isInviteOnly()) {
        channel->removeInvited(client); // Necesitarás implementar este método
    }

    // Construir mensaje JOIN
    std::string join_msg = ":" + client->getNickname() + "!" + client->getRealname() + 
                          "@localhost JOIN :" + channel_name + "\r\n";
    channel->sendToAll(join_msg, NULL);

    // Enviar tema del canal o aviso de no tema
    if (!channel->getTopic().empty()) {
        std::string topic_msg = ":server 332 " + client->getNickname() + " " + channel_name + " :" + channel->getTopic() + "\r\n";
        send(client_fd, topic_msg.c_str(), topic_msg.size(), 0);
    } else {
        std::string notopic_msg = ":server 331 " + client->getNickname() + " " + channel_name + " :No topic is set\r\n";
        send(client_fd, notopic_msg.c_str(), notopic_msg.size(), 0);
    }

    // Construir lista de usuarios (operadores primero)
    std::string users_list;
    const std::set<Client*>& members = channel->getClients();
    
    for (std::set<Client*>::const_iterator it = members.begin(); it != members.end(); ++it) {
        Client* member = *it;
        if (channel->isOperator(member)) {
            users_list += "@";
        }
        users_list += member->getNickname() + " ";
    }

    if (!users_list.empty()) {
        users_list.erase(users_list.size() - 1); // Eliminar último espacio
    }

    // Enviar lista de nombres
    std::string names_msg = ":server 353 " + client->getNickname() + " = " + channel_name + " :" + users_list + "\r\n";
    std::string end_msg = ":server 366 " + client->getNickname() + " " + channel_name + " :End of /NAMES list\r\n";
    send(client_fd, names_msg.c_str(), names_msg.size(), 0);
    send(client_fd, end_msg.c_str(), end_msg.size(), 0);
}

// void CommandHandler::handleJoinCommand(int client_fd, const std::string& channel_name_raw,const std::string& password, IRCServer& server) 
// {
//     std::string channel_name = channel_name_raw;
    
//     std::string err_msg = "CHANEL NAME == " + channel_name + "\n" ;
//     send(client_fd, err_msg.c_str(), err_msg.size(), 0);

//     // Limpiar el nombre del canal
//     channel_name.erase(channel_name.find_last_not_of("\r\n") + 1);
//     channel_name.erase(0, channel_name.find_first_not_of(" "));
//     channel_name.erase(channel_name.find_last_not_of(" ") + 1);
    
//     server.getChannelsBook().getChannel(channel_name)->getPassword().empty();
//     sendError(client_fd, "llego", "??????????????");
//     // 1. Verificar si el canal requiere contraseña
//     Channel* channel = server.getChannelsBook().getChannel(channel_name);
//     if (channel && !channel->getPassword().empty())
//     {
//         // 2. Comprobar contraseña proporcionada
//         if (password != server.getChannelsBook().getChannel(channel_name)->getPassword()) 
//         {
//             std::string err_msg = ":server 475 " + server.getClientsBook().getClient(client_fd)->getNickname() + " " + channel_name + " :Cannot join channel (+k) - invalid password\r\n";
//             send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//             return;
//         }
//     }
        
//     // Validar nombre del canal
//     // err_msg = "CHANEL NAME == " + channel_name + "\n";
//     // send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//     if (channel_name.empty() || channel_name[0] != '#'/*|| channel_name.find(' ')*/ ) {
//         std::string err_msg = channel_name + ":server 461 JOIN :Invalid channel name.\n Remember that the name mustn´t be empty and must start with '#'.\r\n";
//         send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//         return;
//     }
    
//     Client* client = server.getClientsBook().getClient(client_fd);
//     if (!client) {
//         std::cerr << "ERROR: Client not found for fd " << client_fd << std::endl;
//         return;
//     }

//     // Crear canal si no existe
//     if (!server.getChannelsBook().addChannel(channel_name)) {
//         std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :Channel creation failed\r\n";
//         send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//         return;
//     }

//     Channel* channel = server.getChannelsBook().getChannel(channel_name);

//     // Verificar si ya está en el canal
//     if (channel->hasClient(client)) {
//         std::string msg = ":server 443 " + client->getNickname() + " " + channel_name + " :You're already in that channel\r\n";
//         send(client_fd, msg.c_str(), msg.size(), 0);
//         return;
//     }

//     // Primer usuario = operador
//     if (channel->getClients().empty()) {
//         channel->addOperator(client);
//     }

//     // Unirse al canal
//     channel->addClient(client);
//     client->joinChannel(channel_name);

//     // Construir mensaje JOIN (username placeholder: ~nickname)
//     std::string join_msg = ":" + client->getNickname() + "!~" + client->getNickname() + "@localhost JOIN :" + channel_name + "\r\n";
//     channel->sendToAll(join_msg, NULL);

//     // Enviar tema (332) o aviso de no tema (331)
//     if (!channel->getTopic().empty()) {
//         std::string topic_msg = ":server 332 " + client->getNickname() + " " + channel_name + " :" + channel->getTopic() + "\r\n";
//         send(client_fd, topic_msg.c_str(), topic_msg.size(), 0);
//     } else {
//         std::string notopic_msg = ":server 331 " + client->getNickname() + " " + channel_name + " :No topic is set\r\n";
//         send(client_fd, notopic_msg.c_str(), notopic_msg.size(), 0);
//     }

//     // Construir lista de usuarios (operadores primero)
//     std::string operators;
//     std::string regular_users;
//     const std::set<Client*>& members = channel->getClients();
//     for (std::set<Client*>::const_iterator it = members.begin(); it != members.end(); ++it) {
//         Client* member = *it;
//         if (channel->isOperator(member)) {
//             operators += "@" + member->getNickname() + " ";
//         } else {
//             regular_users += member->getNickname() + " ";
//         }
//     }

//     std::string users = operators + regular_users;
//     if (!users.empty()) users.erase(users.size() - 1); // Eliminar último espacio

//     // Enviar lista de nombres (353) y fin (366)
//     std::string names_msg = ":server 353 " + client->getNickname() + " = " + channel_name + " :" + users + "\r\n";
//     std::string end_msg = ":server 366 " + client->getNickname() + " " + channel_name + " :End of /NAMES list\r\n";
//     send(client_fd, names_msg.c_str(), names_msg.size(), 0);
//     send(client_fd, end_msg.c_str(), end_msg.size(), 0);
// }






// void CommandHandler::handleJoinCommand(int client_fd, const std::string& channel_name_raw, const std::string& password, IRCServer& server) {
//     // Limpiar y validar nombre del canal
//     std::string channel_name = channel_name_raw;
//     channel_name.erase(channel_name.find_last_not_of("\r\n") + 1);
//     channel_name.erase(0, channel_name.find_first_not_of(" "));
//     channel_name.erase(channel_name.find_last_not_of(" ") + 1);

//     // Validación básica del nombre del canal
//     if (channel_name.empty() || channel_name[0] != '#') {
//         std::string err_msg = ":server 403 " + channel_name + " :Invalid channel name\r\n";
//         send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//         return;
//     }

//     Client* client = server.getClientsBook().getClient(client_fd);
//     if (!client) {
//         std::cerr << "ERROR: Client not found for fd " << client_fd << std::endl;
//         return;
//     }

//     // Verificar si el cliente está autenticado
//     if (client->getStage() != CONNECTED) {
//         std::string err_msg = ":server 451 " + client->getNickname() + " :You have not registered\r\n";
//         send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//         return;
//     }

//     // Obtener el canal (puede ser NULL si no existe)
//     Channel* channel = server.getChannelsBook().getChannel(channel_name);

//     // Verificar contraseña solo si el canal existe y tiene contraseña
//     if (channel && !channel->getPassword().empty()) {
//         if (password != channel->getPassword()) {
//             std::string err_msg = ":server 475 " + client->getNickname() + " " + channel_name + " :Cannot join channel (+k) - invalid password\r\n";
//             send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//             return;
//         }
//     }

//     // Crear canal si no existe
//     if (!channel) {
//         if (!server.getChannelsBook().addChannel(channel_name)) {
//             std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :Channel creation failed\r\n";
//             send(client_fd, err_msg.c_str(), err_msg.size(), 0);
//             return;
//         }
//         channel = server.getChannelsBook().getChannel(channel_name);
        
//         // Verificar que se creó correctamente
//         if (!channel) {
//             std::cerr << "CRITICAL ERROR: Failed to create channel " << channel_name << std::endl;
//             return;
//         }
//     }

//     // Verificar si el cliente ya está en el canal
//     if (channel->hasClient(client)) {
//         std::string msg = ":server 443 " + client->getNickname() + " " + channel_name + " :You're already in that channel\r\n";
//         send(client_fd, msg.c_str(), msg.size(), 0);
//         return;
//     }

//     // Primer usuario = operador
//     if (channel->getClients().empty()) {
//         channel->addOperator(client);
//     }

//     // Unirse al canal
//     channel->addClient(client);
//     client->joinChannel(channel_name);

//     // Construir mensaje JOIN
//     std::string join_msg = ":" + client->getNickname() + "!~" + client->getNickname() + "@localhost JOIN :" + channel_name + "\r\n";
//     channel->sendToAll(join_msg, NULL);

//     // Enviar tema del canal o aviso de no tema
//     if (!channel->getTopic().empty()) {
//         std::string topic_msg = ":server 332 " + client->getNickname() + " " + channel_name + " :" + channel->getTopic() + "\r\n";
//         send(client_fd, topic_msg.c_str(), topic_msg.size(), 0);
//     } else {
//         std::string notopic_msg = ":server 331 " + client->getNickname() + " " + channel_name + " :No topic is set\r\n";
//         send(client_fd, notopic_msg.c_str(), notopic_msg.size(), 0);
//     }

//     // Construir lista de usuarios (operadores primero)
//     std::string operators;
//     std::string regular_users;
//     const std::set<Client*>& members = channel->getClients();
    
//     for (std::set<Client*>::const_iterator it = members.begin(); it != members.end(); ++it) {
//         Client* member = *it;
//         if (channel->isOperator(member)) {
//             operators += "@" + member->getNickname() + " ";
//         } else {
//             regular_users += member->getNickname() + " ";
//         }
//     }

//     std::string users = operators + regular_users;
//     if (!users.empty()) users.erase(users.size() - 1); // Eliminar último espacio

//     // Enviar lista de nombres
//     std::string names_msg = ":server 353 " + client->getNickname() + " = " + channel_name + " :" + users + "\r\n";
//     std::string end_msg = ":server 366 " + client->getNickname() + " " + channel_name + " :End of /NAMES list\r\n";
//     send(client_fd, names_msg.c_str(), names_msg.size(), 0);
//     send(client_fd, end_msg.c_str(), end_msg.size(), 0);
// }





void CommandHandler::handlePrivMsgCommand(int client_fd, const std::string& target, const std::string& message, IRCServer& server) 
{
    Client* sender = server.getClientsBook().getClient(client_fd);
    
    // 1. Validar estado del cliente
    if (!sender || sender->getStage() != CONNECTED) 
    {
        std::string err_msg = ":server 451 * :You have not registered\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // 2. Validar parámetros
    if (target.empty()) {
        std::string err_msg = ":server 411 " + sender->getNickname() + " :No recipient given\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }
    
    if (message.empty()) {
        std::string err_msg = ":server 412 " + sender->getNickname() + " :No text to send\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // 3. Determinar tipo de destino (canal o usuario)
    if (target[0] == '#') {
        // Mensaje a canal
        Channel* channel = server.getChannelsBook().getChannel(target);
        
        if (!channel) {
            std::string err_msg = ":server 403 " + sender->getNickname() + " " + target + " :No such channel\r\n";
            send(client_fd, err_msg.c_str(), err_msg.size(), 0);
            return;
        }
        
        if (!channel->hasClient(sender)) {
            std::string err_msg = ":server 404 " + sender->getNickname() + " " + target + " :Cannot send to channel\r\n";
            send(client_fd, err_msg.c_str(), err_msg.size(), 0);
            return;
        }

        // Construir y enviar mensaje
        std::string msg = ":" + sender->getNickname() + "!" + sender->getRealname() + 
                        " PRIVMSG " + target + " :" + message + "\r\n";
        channel->sendToAll(msg, sender);
    } 
    else {
        // Mensaje privado
        Client* receiver = server.getClientsBook().getClientByNick(target);
        
        if (!receiver|| receiver->getStage() != CONNECTED) {
            std::string err_msg = ":server 401 " + sender->getNickname() + " " + target + " :No such nick/channel\r\n";
            send(client_fd, err_msg.c_str(), err_msg.size(), 0);
            return;
        }

        // Construir y enviar mensaje
        std::string msg = ":" + sender->getNickname() + "!" + sender->getRealname() + "@"  + 
                        " PRIVMSG " + target + " :" + message + "\r\n";
        send(receiver->getFd(), msg.c_str(), msg.size(), 0);
    }
}














void CommandHandler::handlePartCommand(int client_fd, const std::string& channel_name, const std::string& reason, IRCServer& server) {
    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client || client->getStage() != CONNECTED) {
        std::string err_msg = ":server 451 * :You have not registered\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // Validar formato del canal
    if (channel_name.empty() || channel_name[0] != '#') {
        std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :No such channel\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        std::string err_msg = ":server 403 " + client->getNickname() + " " + channel_name + " :No such channel\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // Verificar si el cliente está en el canal
    if (!channel->hasClient(client)) {
        std::string err_msg = ":server 442 " + client->getNickname() + " " + channel_name + " :You're not on that channel\r\n";
        send(client_fd, err_msg.c_str(), err_msg.size(), 0);
        return;
    }

    // Notificar a los miembros del canal
    std::string part_msg = ":" + client->getNickname() + "!~" + client->getRealname() + "@localhost PART " + channel_name;
    if (!reason.empty()) part_msg += " :" + reason;
    part_msg += "\r\n";
    
    channel->sendToAll(part_msg, NULL); // Enviar a todos, incluido el remitente

    // Eliminar al cliente del canal
    channel->removeClient(client);
    client->leaveChannel(channel_name);

    // Si el canal queda vacío, eliminarlo
    if (channel->getClients().empty()) {
        server.getChannelsBook().removeChannel(channel_name);
    }
}

void CommandHandler::sendToAllClients(const std::string& message, int sender_fd, IRCServer &server) 
{
   
    
    const std::map<int, Client*>& clients = server.getClientsBook().getmap();
    for (std::map<int, Client*>::const_iterator it = clients.begin(); it != clients.end(); ++it) {
        Client* client = it->second;

        // 🔒 Verificamos que esté conectado y que no sea el emisor
        if (client && client->getFd() != sender_fd && client->getStage() == CONNECTED) {
            send(client->getFd(), message.c_str(), message.length(), 0);
        }
    }
}

// void CommandHandler::handleModeCommand(int client_fd, const std::string& target, const std::string& mode_str, const std::vector<std::string>& args,IRCServer& server) 
// {
//     Client* client = server.getClientsBook().getClient(client_fd);
//     if (!client || client->getStage() != CONNECTED) 
//     {
//         sendError(client_fd, "451", ":You have not registered");
//         return;
//     }

//     // Si es un canal
//     if (target[0] == '#') 
//     {
//         Channel* channel = server.getChannelsBook().getChannel(target);
//         if (!channel) 
//         {
//             sendError(client_fd, "403", target + " :No such channel");
//             return;
//         }

//         // Solo operadores pueden cambiar modos
//         if (!channel->isOperator(client)) 
//         {
//             sendError(client_fd, "482", target + " :You're not channel operator");
//             return;
//         }

//         // Consulta de modos (sin argumentos)
//         if (mode_str.empty()) 
//         {
//             std::string mode_reply = ":server 324 " + client->getNickname() + " " + target + " " + channel->getModeString() + "\r\n";
//             send(client_fd, mode_reply.c_str(), mode_reply.size(), 0);
//             return;
//         }

//         // Procesar cambios de modo: +modo o -modo
//         char sign = '+';
//         size_t arg_index = 0;
//         std::string changes;
//         std::string mode_args;

//         for (size_t i = 0; i < mode_str.size(); ++i) 
//         {
//             char c = mode_str[i];
            
//             if (c == '+' || c == '-') 
//             {
//                 sign = c;
//                 continue;
//             }

//             switch (c) 
//             {
//                 case 'i': // Invite-only
//                 case 't': // Topic restriction
//                     channel->setMode(c, sign == '+');
//                     changes += sign;
//                     changes += c;
//                     break;
                    
//                 case 'k': // Password
//                     if (sign == '+') 
//                     {
//                         if (arg_index >= args.size()) 
//                         {
//                             sendError(client_fd, "461", "MODE k :Not enough parameters");
//                             return;
//                         }
//                         channel->setMode(c, true, args[arg_index]);
//                         changes += sign;
//                         changes += c;
//                         mode_args += " " + args[arg_index];
//                         arg_index++;
//                     } 
//                     else 
//                     {
//                         channel->setMode(c, false);
//                         changes += sign;
//                         changes += c;
//                     }
//                     break;

//                 case 'o': // Operator privilege
//                     if (arg_index >= args.size()) 
//                     {
//                         sendError(client_fd, "461", "MODE o :Not enough parameters");
//                         return;
//                     }
                    
//                     {
//                         Client* target_client = server.getClientsBook().getClientByNick(args[arg_index]);
//                         if (!target_client) 
//                         {
//                             sendError(client_fd, "401", args[arg_index] + " :No such nick");
//                             return;
//                         }

//                         if (sign == '+') 
//                         {
//                             channel->addOperator(target_client);
//                         } 
//                         else 
//                         {
//                             channel->removeOperator(target_client);
//                         }
//                         changes += sign;
//                         changes += c;
//                         mode_args += " " + args[arg_index];
//                         arg_index++;
//                     }
//                     break;

//                 case 'l': // User limit
//                     if (sign == '+') 
//                     {
//                         if (arg_index >= args.size()) 
//                         {
//                             sendError(client_fd, "461", "MODE l :Not enough parameters");
//                             return;
//                         }
//                         const std::string& limit_str = args[arg_index];
//                         if (!std::isdigit(limit_str[0])) 
//                         {
//                             sendError(client_fd, "696", target + " l :Invalid limit format");
//                             return;
//                         }
//                         channel->setMode(c, true, limit_str);
//                         changes += sign;
//                         changes += c;
//                         mode_args += " " + limit_str;
//                         arg_index++;
//                     } 
//                     else 
//                     {
//                         channel->setMode(c, false);
//                         changes += sign;
//                         changes += c;
//                     }
//                     break;

//                     default:
//                     sendError(client_fd, "472", std::string(1, c) + " :is unknown mode char");
//                     break;
//             }
//         }

//         // Notificar a todos en el canal
//         if (!changes.empty()) 
//         {
//             std::string msg = ":" + client->getNickname() + "!" + client->getRealname() + "@localhost MODE " + target + " " + changes + mode_args + "\r\n";
//             channel->sendToAll(msg, NULL);
//         }
//     }
//         // Modos de usuario no implementados
//         else 
//         {
//             sendError(client_fd, "502", ":User modes not supported");
//         }
// }





void CommandHandler::handleInviteCommand(int client_fd, const std::string& nick, const std::string& channel_name, IRCServer& server) {
    // 1. Verificar cliente autenticado
    Client* inviter = server.getClientsBook().getClient(client_fd);
    if (!inviter || inviter->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered");
        return;
    }

    // 2. Validar parámetros
    if (nick.empty() || channel_name.empty()) {
        sendError(client_fd, "461", "INVITE :Not enough parameters");
        return;
    }

    // 3. Verificar que el canal existe
    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        sendError(client_fd, "403", channel_name + " :No such channel");
        return;
    }

    // 4. Verificar que el inviter está en el canal
    if (!channel->hasClient(inviter)) {
        sendError(client_fd, "442", channel_name + " :You're not on that channel");
        return;
    }

    // 5. Verificar permisos (operador o no es +i)
    if (channel->isInviteOnly() && !channel->isOperator(inviter)) {
        sendError(client_fd, "482", channel_name + " :You must be channel operator");
        return;
    }

    // 6. Verificar que el usuario objetivo existe
    Client* target = server.getClientsBook().getClientByNick(nick);
    if (!target) {
        sendError(client_fd, "401", nick + " :No such nick");
        return;
    }

    // 7. Verificar que no está ya en el canal
    if (channel->hasClient(target)) {
        sendError(client_fd, "443", nick + " " + channel_name + " :is already on channel");
        return;
    }

    // 8. Invitar al cliente
    channel->inviteClient(target);

    // 9. Mensaje al invitado (formato estándar)
    std::string msg = ":" + inviter->getNickname() + "!" + inviter->getRealname() + 
                     "@localhost INVITE " + nick + " :" + channel_name + "\r\n";
    send(target->getFd(), msg.c_str(), msg.size(), 0);
    
    // 10. Mensaje de confirmación al inviter (RPL_INVITING)
    std::string rpl = ":server 341 " + inviter->getNickname() + " " + nick + " " + channel_name + "\r\n";
    send(client_fd, rpl.c_str(), rpl.size(), 0);
    
    // 11. Mensaje a operadores del canal
    if (channel->isInviteOnly()) {
        std::string op_msg = ":" + inviter->getNickname() + "!" + inviter->getRealname() + 
                            "@localhost INVITE " + nick + " " + channel_name + "\r\n";
        channel->sendToAll(op_msg, inviter);
    }
}


// void CommandHandler::handleModeCommand(int client_fd, const std::string& target, 
//                                       const std::string& mode_str, 
//                                       const std::vector<std::string>& args,
//                                       IRCServer& server) 
// {
//     Client* client = server.getClientsBook().getClient(client_fd);
//     if (!client || client->getStage() != CONNECTED) {
//         sendError(client_fd, "451", ":You have not registered");
//         return;
//     }

//     // Manejo para canales
//     if (!target.empty() && target[0] == '#') 
//     {
//         Channel* channel = server.getChannelsBook().getChannel(target);
//         if (!channel) {
//             sendError(client_fd, "403", target + " :No such channel");
//             return;
//         }

//         // Verificar privilegios de operador
//         if (!channel->isOperator(client)) {
//             sendError(client_fd, "482", target + " :You're not channel operator");
//             return;
//         }

//         // Consulta de modos (sin cambios)
//         if (mode_str.empty()) {
//             std::string reply = ":server 324 " + client->getNickname() + " " + target + " " + channel->getModeString() + "\r\n";
//             send(client_fd, reply.c_str(), reply.size(), 0);
//             return;
//         }

//         // Procesar secuencia de modos
//         char current_sign = '+';
//         size_t arg_index = 0;
//         std::string changes;
//         std::string mode_args;
//         bool valid_mode = true;

//         for (size_t i = 0; i < mode_str.size() && valid_mode; ++i) 
//         {
//             char mode_char = mode_str[i];
            
//             // Manejar cambio de signo (+/-)
//             if (mode_char == '+' || mode_char == '-') {
//                 current_sign = mode_char;
//                 continue;
//             }

//             // Procesar cada modo específico
//             switch (mode_char) 
//             {
//                 case 'i': // Modo invite-only
//                 case 't': // Modo topic restringido
//                     channel->setMode(mode_char, current_sign == '+');
//                     changes += current_sign;
//                     changes += mode_char;
//                     break;
                    
//                 case 'k': // Contraseña del canal
//                     if (current_sign == '+') {
//                         if (arg_index >= args.size()) {
//                             sendError(client_fd, "461", "MODE k :Not enough parameters");
//                             valid_mode = false;
//                             break;
//                         }
//                         channel->setMode(mode_char, true, args[arg_index]);
//                         mode_args += " " + args[arg_index++];
//                     } else {
//                         channel->setMode(mode_char, false);
//                     }
//                     changes += current_sign;
//                     changes += mode_char;
//                     break;

//                 case 'o': // Privilegios de operador
//                 {
//                     if (arg_index >= args.size()) {
//                         sendError(client_fd, "461", "MODE o :Not enough parameters");
//                         valid_mode = false;
//                         break;
//                     }
                    
//                     Client* target_client = server.getClientsBook().getClientByNick(args[arg_index]);
//                     if (!target_client) {
//                         sendError(client_fd, "401", args[arg_index] + " :No such nick");
//                         valid_mode = false;
//                         break;
//                     }

//                     if (current_sign == '+') {
//                         channel->addOperator(target_client);
//                     } else {
//                         channel->removeOperator(target_client);
//                     }
//                     changes += current_sign;
//                     changes += mode_char;
//                     mode_args += " " + args[arg_index++];
//                     break;
//                 }

//                 case 'l': // Límite de usuarios
//                     if (current_sign == '+') {
//                         if (arg_index >= args.size()) {
//                             sendError(client_fd, "461", "MODE l :Not enough parameters");
//                             valid_mode = false;
//                             break;
//                         }
//                         const std::string& limit = args[arg_index];
//                         if (!std::isdigit(limit[0])) {
//                             sendError(client_fd, "696", target + " l :Invalid limit format");
//                             valid_mode = false;
//                             break;
//                         }
//                         channel->setMode(mode_char, true, limit);
//                         mode_args += " " + limit;
//                         arg_index++;
//                     } else {
//                         channel->setMode(mode_char, false);
//                     }
//                     changes += current_sign;
//                     changes += mode_char;
//                     break;

//                 default: // Modo desconocido
//                     sendError(client_fd, "472", std::string(1, mode_char) + " :is unknown mode char");
//                     valid_mode = false;
//                     break;
//             }
//         }

//         // Notificar cambios si fueron válidos
//         if (valid_mode && !changes.empty()) {
//             std::string msg = ":" + client->getNickname() + "!" + client->getRealname() + 
//                             "@localhost MODE " + target + " " + changes + mode_args + "\r\n";
//             channel->sendToAll(msg, NULL);
//         }
//     }
//     else // Modos de usuario no soportados
//     {
//         sendError(client_fd, "502", ":User modes not supported");
//     }
// }


void CommandHandler::handleModeCommand(int client_fd, const std::string& target, 
                                      const std::string& mode_str, 
                                      const std::vector<std::string>& args,
                                      IRCServer& server) 
{
    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client || client->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered");
        return;
    }

    // Manejo para canales
    if (!target.empty() && target[0] == '#') 
    {
        Channel* channel = server.getChannelsBook().getChannel(target);
        if (!channel) {
            sendError(client_fd, "403", target + " :No such channel");
            return;
        }

        // Verificar privilegios de operador
        if (!channel->isOperator(client)) {
            sendError(client_fd, "482", target + " :You're not channel operator");
            return;
        }

        // Consulta de modos (sin cambios)
        if (mode_str.empty()) {
            std::string reply = ":server 324 " + client->getNickname() + " " + target + " " + channel->getModeString() + "\r\n";
            send(client_fd, reply.c_str(), reply.size(), 0);
            return;
        }

        // Procesar secuencia de modos
        char current_sign = '+';
        size_t arg_index = 0;
        std::string changes;
        std::string mode_args;
        bool valid_mode = true;

        for (size_t i = 0; i < mode_str.size() && valid_mode; ++i) 
        {
            char mode_char = mode_str[i];
            
            // Manejar cambio de signo (+/-)
            if (mode_char == '+' || mode_char == '-') {
                current_sign = mode_char;
                continue;
            }

            // Procesar cada modo específico
            switch (mode_char) 
            {
                case 'i': // Modo invite-only
                case 't': // Modo topic restringido
                    channel->setMode(mode_char, current_sign == '+');
                    changes += current_sign;
                    changes += mode_char;
                    break;
                    
                case 'k': // Contraseña del canal
                    if (current_sign == '+') {
                        if (arg_index >= args.size()) {
                            sendError(client_fd, "461", "MODE k :Not enough parameters");
                            valid_mode = false;
                            break;
                        }
                        channel->setMode(mode_char, true, args[arg_index]);
                        mode_args += " " + args[arg_index++];
                    } else {
                        channel->setMode(mode_char, false);
                    }
                    changes += current_sign;
                    changes += mode_char;
                    break;

                case 'o': // Privilegios de operador
                {
                    if (arg_index >= args.size()) {
                        sendError(client_fd, "461", "MODE o :Not enough parameters");
                        valid_mode = false;
                        break;
                    }
                    
                    Client* target_client = server.getClientsBook().getClientByNick(args[arg_index]);
                    if (!target_client) {
                        sendError(client_fd, "401", args[arg_index] + " :No such nick");
                        valid_mode = false;
                        break;
                    }

                    if (current_sign == '+') {
                        channel->addOperator(target_client);
                    } else {
                        channel->removeOperator(target_client);
                    }
                    changes += current_sign;
                    changes += mode_char;
                    mode_args += " " + args[arg_index++];
                    break;
                }

                case 'l': // Límite de usuarios
                    if (current_sign == '+') {
                        if (arg_index >= args.size()) {
                            sendError(client_fd, "461", "MODE l :Not enough parameters");
                            valid_mode = false;
                            break;
                        }
                        const std::string& limit = args[arg_index];
                        if (!std::isdigit(limit[0])) {
                            sendError(client_fd, "696", target + " l :Invalid limit format");
                            valid_mode = false;
                            break;
                        }
                        channel->setMode(mode_char, true, limit);
                        mode_args += " " + limit;
                        arg_index++;
                    } else {
                        channel->setMode(mode_char, false);
                    }
                    changes += current_sign;
                    changes += mode_char;
                    break;

                default: // Modo desconocido
                    sendError(client_fd, "472", std::string(1, mode_char) + " :is unknown mode char");
                    valid_mode = false;
                    break;
            }
        }

        // Notificar cambios si fueron válidos
        if (valid_mode && !changes.empty()) {
            std::string msg = ":" + client->getNickname() + "!" + client->getRealname() + 
                            "@localhost MODE " + target + " " + changes + mode_args + "\r\n";
            channel->sendToAll(msg, NULL);
        }
    }
    else // Modos de usuario no soportados
    {
        sendError(client_fd, "502", ":User modes not supported");
    }
}

void CommandHandler::handleKickCommand(int client_fd, const std::string& channel_name, 
                                      const std::string& user, const std::string& reason, 
                                      IRCServer& server) {
    // 1. Verificar cliente autenticado
    Client* issuer = server.getClientsBook().getClient(client_fd);
    if (!issuer || issuer->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered");
        return;
    }

    // 2. Validar parámetros mínimos
    if (channel_name.empty() || user.empty()) {
        sendError(client_fd, "461", "KICK :Not enough parameters");
        return;
    }

    // 3. Verificar que el canal existe
    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        sendError(client_fd, "403", channel_name + " :No such channel");
        return;
    }

    // 4. Verificar que el solicitante es operador
    if (!channel->isOperator(issuer)) {
        sendError(client_fd, "482", channel_name + " :You're not channel operator");
        return;
    }

    // 5. Verificar que el usuario objetivo existe y está en el canal
    Client* target = server.getClientsBook().getClientByNick(user);
    if (!target) {
        sendError(client_fd, "401", user + " :No such nick");
        return;
    }
    if (!channel->hasClient(target)) {
        sendError(client_fd, "441", user + " " + channel_name + " :They aren't on that channel");
        return;
    }

    // 6. Construir mensaje de expulsión
    std::string kick_msg = ":" + issuer->getNickname() + "!" + issuer->getRealname() +
                          "@localhost KICK " + channel_name + " " + user;
    if (!reason.empty()) {
        kick_msg += " :" + reason;
    }
    kick_msg += "\r\n";

    // 7. Enviar notificación a todos en el canal
    channel->sendToAll(kick_msg, NULL);

    // 8. Eliminar al usuario del canal
    channel->removeClient(target);
    target->leaveChannel(channel_name);

    // 9. Si el usuario era operador, quitar privilegios
    if (channel->isOperator(target)) {
        channel->removeOperator(target);
    }

    // 10. Notificar al usuario expulsado
    //send(target->getFd(), kick_msg.c_str(), kick_msg.size(), 0);
    
    // 11. Eliminar canal si queda vacío
    if (channel->getClients().empty()) {
        server.getChannelsBook().removeChannel(channel_name);
    }
}

std::string intToString(int value) {
    std::ostringstream oss;
    oss << value;
    return oss.str();
}

void CommandHandler::handleTopicCommand(int client_fd, const std::string& channel_name, 
                                       const std::string& new_topic, IRCServer& server) {
    // 1. Verificar cliente autenticado
    Client* client = server.getClientsBook().getClient(client_fd);
    if (!client || client->getStage() != CONNECTED) {
        sendError(client_fd, "451", ":You have not registered");
        return;
    }

    // 2. Validar parámetros mínimos
    if (channel_name.empty()) {
        sendError(client_fd, "461", "TOPIC :Not enough parameters");
        return;
    }

    // 3. Verificar que el canal existe
    Channel* channel = server.getChannelsBook().getChannel(channel_name);
    if (!channel) {
        sendError(client_fd, "403", channel_name + " :No such channel");
        return;
    }

    // 4. Verificar que el cliente está en el canal
    if (!channel->hasClient(client)) {
        sendError(client_fd, "442", channel_name + " :You're not on that channel");
        return;
    }

    // 5. Si no se especifica nuevo tema: mostrar tema actual
    if (new_topic.empty()) {
        if (channel->getTopic().empty()) {
            std::string reply = ":server 331 " + client->getNickname() + " " + channel_name + " :No topic is set\r\n";
            send(client_fd, reply.c_str(), reply.size(), 0);
        } else {
            std::string reply = ":server 332 " + client->getNickname() + " " + channel_name + " :" + channel->getTopic() + "\r\n";
            send(client_fd, reply.c_str(), reply.size(), 0);
        }
        return;
    }

    // 6. Verificar permisos para cambiar el tema
    if (channel->isTopicRestricted() && !channel->isOperator(client)) {
        sendError(client_fd, "482", channel_name + " :You must be channel operator to change the topic");
        return;
    }

    // 7. Actualizar el tema
    channel->setTopic(new_topic);

    // 8. Notificar a todos en el canal
    std::string msg = ":" + client->getNickname() + "!" + client->getRealname() + 
                     "@localhost TOPIC " + channel_name + " :" + new_topic + "\r\n";
    channel->sendToAll(msg, NULL);

    // 9. Confirmación al cliente que cambió el tema
//    std::ostringstream oss;
//     oss << time(NULL);
//     std::string timestamp = oss.str();
    
//     std::string rpl = ":server 333 " + client->getNickname() + " " + channel_name + 
//                      " " + client->getNickname() + " " + timestamp + "\r\n";
//     send(client_fd, rpl.c_str(), rpl.size(), 0);
    std::string rpl = ":server 333 " + client->getNickname() + " " + channel_name + 
                     " " + client->getNickname() + " " + intToString(time(NULL)) + "\r\n";
    send(client_fd, rpl.c_str(), rpl.size(), 0);

}


// ===== Archivo: ./src/Channel.cpp ===== //
#include "Channel.hpp"
#include "Client.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>



// Constructor de Channel
Channel::Channel(const std::string& name)
	: _name(name), _topic(""), _password(""), _userLimit(0), _inviteOnly(false), _topicRestricted(false) {}

// Getter para el nombre del canal
const std::string& Channel::getName() const {
	return _name;
}

// Getter y setter para el topic del canal
const std::string& Channel::getTopic() const {
	return _topic;
}

void Channel::setTopic(const std::string& topic) {
	_topic = topic;
}

// Comprobación de si el canal es solo por invitación
bool Channel::isInviteOnly() const {
	return _inviteOnly;
}

void Channel::setInviteOnly(bool val) {
	_inviteOnly = val;
}

// Comprobación de si el canal tiene restricciones en el tema
bool Channel::isTopicRestricted() const {
	return _topicRestricted;
}

void Channel::setTopicRestricted(bool val) {
	_topicRestricted = val;
}

// Getter y setter para la contraseña del canal
const std::string& Channel::getPassword() const {
  
    
	return _password;
}

void Channel::setPassword(const std::string& pass) {
	_password = pass;
}

// Getter y setter para el límite de usuarios en el canal
size_t Channel::getUserLimit() const {
	return _userLimit;
}

void Channel::setUserLimit(size_t limit) {
	_userLimit = limit;
}

// Agregar un cliente al canal
void Channel::addClient(Client* client) {
	_clients.insert(client);
}

// Eliminar un cliente del canal
void Channel::removeClient(Client* client) {
	_clients.erase(client);
    _operators.erase(client);  // También quitar de operadores si lo era
    _invited.erase(client); 
}

// Verificar si un cliente está en el canal
bool Channel::hasClient(Client* client) const {
	return _clients.find(client) != _clients.end();
}

// Agregar un operador al canal
void Channel::addOperator(Client* client) {
	_operators.insert(client);
}

// Eliminar un operador del canal
void Channel::removeOperator(Client* client) {
	_operators.erase(client);
}

// Verificar si un cliente es operador en el canal
bool Channel::isOperator(Client* client) const {
	return _operators.find(client) != _operators.end();
}

// Invitar a un cliente al canal
void Channel::inviteClient(Client* client) {
	_invited.insert(client);
}

// Verificar si un cliente ha sido invitado
bool Channel::isInvited(Client* client) const {
	return _invited.find(client) != _invited.end();
}

// Obtener la lista de clientes del canal
const std::set<Client*>& Channel::getClients() const {
	return _clients;
}

void Channel::removeInvited(Client* client) {
    _invited.erase(client);
}

// void Channel::sendToAll(const std::string& message, Client* sender)
// {
//     for (std::set<Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it) 
// 	{
//         Client* client = *it;

//         if (client == NULL)
//             continue;

//         // Si hay sender, y el cliente es el sender, lo saltamos
//         if (sender && client->getFd() == sender->getFd())
//             continue;

//         send(client->getFd(), message.c_str(), message.length(), 0);
//     }
// }
void Channel::sendToAll(const std::string& message, Client* sender)
{
    for (std::set<Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it) 
    {
        Client* client = *it;
        if (!client) 
            continue;
        if (sender && client == sender)
            continue;

        ssize_t bytes_sent = send(client->getFd(), message.c_str(), message.length(), 0);
        if (bytes_sent == -1) {
            std::cerr << "Failed to send message to fd " << client->getFd() << std::endl;
            // opcional: puedes marcar al cliente como desconectado, etc.
        }
    }
}

void Channel::setMode(char mode, bool enabled, const std::string& arg) 
{
    switch (mode) {
        case 'i': _inviteOnly = enabled; break;
        case 't': _topicRestricted = enabled; break;
        case 'k': 
            if (enabled) _password = arg;
            else _password = "";
            break;
        case 'o':
            // Implementado en los métodos addOperator/removeOperator
            break;
        case 'l':
            if (enabled) _userLimit = std::atoi(arg.c_str());
            else _userLimit = 0;
            break;
    }
}

std::string Channel::getModeString() const 
{
    std::ostringstream oss;
    oss << "+";
    if (_inviteOnly) oss << "i";
    if (_topicRestricted) oss << "t";
    if (!_password.empty()) oss << "k";
    if (_userLimit > 0) oss << "l";
    return oss.str();
}


// ===== Archivo: ./src/BookClient.cpp ===== //
#include "BookClient.hpp"
#include <iostream>

bool BookClient::addClient(int fd, std::string nick, std::string user, AuthStage stage) 
{
    if (clients.find(fd) != clients.end()) return false;

    Client* new_client = NULL;
    try {
        new_client = new Client(fd, nick, user, stage);
    } 
    catch (const std::bad_alloc& e) {
        std::cerr << "Error: could not allocate memory for new Client: " << e.what() << std::endl;
        return false;
    }

    try {
        clients.insert(std::make_pair(fd, new_client));
    } 
    catch (...) {
        delete new_client;
        return false;
    }
    return true;


}


void BookClient::printbook()
{
    std::map<int, Client *>::iterator it = clients.begin();
        while(it != clients.end())
        {
            std::cout << "nick = " <<it->second->getNickname() <<  " fd = " << it->first  << std::endl;
            it ++;
        }
}

BookClient::BookClient()
{

}
BookClient::~BookClient()
{
    std::map<int, Client *>::iterator it = clients.begin();
        while(it != clients.end())
        {
            delete it->second;
            it ++;
        }
        clients.clear();

}

void BookClient::removeClient(int fd) {
    std::map<int, Client*>::iterator it = clients.find(fd);
    if (it != clients.end()) {
        delete it->second;   // Liberar memoria del Client
        clients.erase(it);   // Eliminar entrada del mapa
    }
}

bool BookClient::nickExists(const std::string& nick) 
{
    std::map<int, Client *>::iterator it = clients.begin();
    while(it != clients.end())
    {
        if (it->second->getNickname() == nick)
        {
            
            return true;
        }
        it ++;
    }
    return false;
}

Client* BookClient::getClientByNick(const std::string& nick) 
{
    std::map<int, Client*>::iterator it;
    for (it = clients.begin(); it != clients.end(); ++it) {
        if (it->second->getNickname() == nick) {
            return it->second;
        }
    }
    return NULL;
}

bool BookClient::fdExists(int fd)
{
    std::map<int, Client *>::iterator it = clients.find(fd);
    if(it != clients.end())
    {
        return true;
    }
    return false;
}

Client* BookClient::getClient(int fd) 
{
    if (clients.find(fd) != clients.end())
        return clients[fd];
    return NULL;
}

std::map<int, Client *>& BookClient::getmap() 
{
    return clients;
}



// ===== Archivo: ./src/Server.cpp ===== //
#include "Server.hpp"
#include "CommandHandler.hpp"
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <fcntl.h> 
#include <unistd.h>
#include <sys/socket.h>
#include <cerrno>
#include <arpa/inet.h>
#include <poll.h>
#include <sstream>
#include <map>
#include <cstdio> // Necesario para perror()

// Constructor del servidor
// IRCServer::IRCServer(int port, const std::string& password) : port(port), password(password) {
//     struct sockaddr_in server_addr;

//     // Crear el socket
//     server_fd = socket(AF_INET, SOCK_STREAM, 0);
//     if (server_fd < 0) {
//         std::perror("socket");  // Si falla al crear el socket, termina el programa
//         std::exit(EXIT_FAILURE);
//     }

  
//     // Configurar la dirección del servidor
//     std::memset(&server_addr, 0, sizeof(server_addr));
//     server_addr.sin_family = AF_INET;
//     server_addr.sin_addr.s_addr = INADDR_ANY;  // Escuchar en todas las interfaces de red
//     server_addr.sin_port = htons(port);  // Asignar el puerto proporcionado

//     // Asociar el socket con la dirección del servidor
//     if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
//         std::perror("bind");  // Si falla la asociación, termina el programa
//         std::exit(EXIT_FAILURE);
//     }

//     // Escuchar conexiones entrantes
//     if (listen(server_fd, 10) < 0) {
//         std::perror("listen");  // Si falla al escuchar, termina el programa
//         std::exit(EXIT_FAILURE);
//     }

//     // Preparar el conjunto de clientes con el socket del servidor
//     struct pollfd pfd;
//     pfd.fd = server_fd;
//     pfd.events = POLLIN;  // Indica que estamos esperando eventos de lectura
//     clients.push_back(pfd);  // Añadir el servidor a la lista de clientes

//     std::cout << "IRC Server running on port " << port << " and awaiting connections..." << std::endl;
// }

IRCServer::IRCServer(int port, const std::string& password) : port(port), password(password) {
    struct sockaddr_in server_addr;

    // Crear el socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        std::perror("socket");
        std::exit(EXIT_FAILURE);
    }

    // 🔥 Añadir opción SO_REUSEADDR para permitir reusar el puerto inmediatamente
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) )
    {
        std::perror("setsockopt");
        std::exit(EXIT_FAILURE);
    }

    // Configurar la dirección del servidor
    std::memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);

    // Asociar el socket con la dirección del servidor
    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        std::perror("bind");
        std::exit(EXIT_FAILURE);
    }

    // Escuchar conexiones entrantes
    if (listen(server_fd, 10) < 0) {
        std::perror("listen");
        std::exit(EXIT_FAILURE);
    }

    // Preparar el conjunto de clientes con el socket del servidor
    struct pollfd pfd;
    pfd.fd = server_fd;
    pfd.events = POLLIN;
    clients.push_back(pfd);

    std::cout << "IRC Server running on port " << port << " and awaiting connections..." << std::endl;
}

BookClient& IRCServer::getClientsBook()
{
    return this->clients_info;
}
ChannelBook& IRCServer::getChannelsBook()
{
    return this->channels;
}

// Destructor del servidor
IRCServer::~IRCServer() 
{
    close(server_fd);
    
    // Cerrar todos los sockets de clientes
    for (size_t i = 0; i < clients.size(); ++i) {
        if (clients[i].fd != server_fd) {
            close(clients[i].fd);
        }
    }
    std::cout << "Server has shut down. All client connections have been closed." << std::endl;

}





// Solicitar el nickname

void IRCServer::acceptClient() 
{
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);
    if (client_fd < 0) {
        std::perror("accept");
        return;
    }

    int flags = fcntl(client_fd, F_GETFL, 0);
    if (flags < 0 || fcntl(client_fd, F_SETFL, flags | O_NONBLOCK) < 0) {
        std::perror("fcntl");
        close(client_fd);
        return;
    }

    // Añadir a la lista de clientes para poll
    struct pollfd pfd;
    pfd.fd = client_fd;
    pfd.events = POLLIN;
    clients.push_back(pfd);

    // Añadir cliente en estado de espera de contraseña
    clients_info.addClient(client_fd, "", "", WAITING_PASSWORD);

    const char* welcome_msg = "Welcome to the IRC Server! Please enter the password:\n";
    send(client_fd, welcome_msg, strlen(welcome_msg), 0);
}


// Eliminar cliente

// void IRCServer::removeClient(int client_fd) {
//     Client* client = clients_info.getClient(client_fd);
//     if (client) {
//         // Limpiar de todos los canales
//         const std::set<std::string>& channels = client->getJoinedChannels();
//         for (std::set<std::string>::const_iterator it = channels.begin(); it != channels.end(); ++it) {
//             Channel* channel = channels_book.getChannel(*it);
//             if (channel) {
//                 channel->removeClient(client);
//             }
//         }
//         // ... resto del código ...
//     }
// }
void IRCServer::removeClient(int client_fd) 
{
    Client* client = clients_info.getClient(client_fd);
    bool client_was_registered = false;
    std::string nickname = "";
    std::string realname = "";  // Añadimos para almacenar realname seguro
    
    // Paso 1: Eliminar al cliente de todos los canales donde está unido
    if (client) 
    {
        client_was_registered = true;
        nickname = client->getNickname();
        realname = client->getRealname();  // Almacenar ANTES de cualquier operación
        
        // Hacer copia de los canales porque leaveChannel modifica el set original
        std::set<std::string> joinedChannels = client->getJoinedChannels();
        
        for (std::set<std::string>::const_iterator it = joinedChannels.begin(); 
             it != joinedChannels.end(); ++it) {
            const std::string& channel_name = *it;
            Channel* channel = channels.getChannel(channel_name);
            
            // VERIFICACIÓN CRÍTICA: Asegurarnos que el canal existe
            if (channel) {
                // Construir mensaje de QUIT ANTES de modificar el cliente
                std::string quit_msg = ":" + nickname + "!~" + realname +  // Usar valor almacenado
                                      "@localhost QUIT :Connection closed\r\n";
                channel->sendToAll(quit_msg, NULL);
                
                // Eliminar al cliente del canal
                channel->removeClient(client);
                
                // Si el canal queda vacío, eliminarlo
                if (channel->getClients().empty()) {
                    channels.removeChannel(channel_name);
                }
            }
        }
    }

    // Paso 2: Cerrar conexión y eliminar de estructuras
    close(client_fd);
    
    // Eliminar de la lista de poll
    for (size_t i = 0; i < clients.size(); ++i) {
        if (clients[i].fd == client_fd) {
            clients.erase(clients.begin() + i);
            break;
        }
    }
    
    // Eliminar del libro de clientes
    clients_info.removeClient(client_fd);
    
    // Paso 3: Log
    if (client_was_registered) {
        std::cout << "Client with nickname: " << nickname
                  << " (fd: " << client_fd << ") has disconnected." << std::endl;
    } else {
        std::cout << "Unregistered client (fd: " << client_fd << ") has disconnected." << std::endl;
    }
}


// Ejecutar el servidor y manejar los eventos
void IRCServer::run() {
    CommandHandler handler;
    while (true) {
        if (clients.empty()) continue;
        if (poll(&clients[0], clients.size(), -1) < 0) {
            std::perror("poll");
            continue;
        }
        // Manejar los eventos para cada cliente
        for (int i = static_cast<int>(clients.size()) - 1; i >= 0; --i) 
        {
            if (clients[i].revents & POLLIN) {
                if (clients[i].fd == server_fd) 
                {
                    acceptClient();  // Aceptar un nuevo cliente
                } 
                else 
                {
                    handleClientData(clients[i].fd, handler);  // Manejar los datos del cliente
                }
            }
        }
        
    }
}



// void IRCServer::handleClientData(int client_fd, CommandHandler &handler) {
//     char buffer[512];
//     memset(buffer, 0, sizeof(buffer));
//     int bytes_received = recv(client_fd, buffer, sizeof(buffer) - 1, 0);

//     if (bytes_received < 0) {
//         if (errno == EAGAIN || errno == EWOULDBLOCK)
//             return;  // No hay datos ahora
//         std::perror("recv handleClientData");
//         removeClient(client_fd);
//         return;
//     }
//     if (bytes_received == 0) {
//         removeClient(client_fd);
//         return;
//     }

//     buffer[bytes_received] = '\0';
//     Client* client = clients_info.getClient(client_fd);
//     if (!client) return;

//     client->getBuffer() += buffer;
//     size_t pos;
//     while ((pos = client->getBuffer().find('\n')) != std::string::npos) {
//         std::string line = client->getBuffer().substr(0, pos);
//         client->getBuffer().erase(0, pos + 1);
//         line.erase(line.find_last_not_of("\r\n") + 1);

//         if (client->getStage() == WAITING_PASSWORD) {
//             if (line != password) {
//                 send(client_fd, "Incorrect password. Connection closed.\n", 40, 0);
//                 removeClient(client_fd);
//                 return;
//             }
//             client->setStage(WAITING_NICKNAME);
//             send(client_fd, "Please enter your nickname:\n", 29, 0);
//             return;
//         }

//         if (client->getStage() == WAITING_NICKNAME) {
//             line.erase(0, line.find_first_not_of(" "));
//             line.erase(line.find_last_not_of(" ") + 1);
//             if (line.empty() || clients_info.nickExists(line)) {
//                 send(client_fd, "Nickname invalid or taken. Try again:\n", 38, 0);
//                 return;
//             }
//             client->setNickname(line);
//             client->setStage(WAITING_USERNAME);
//             send(client_fd, "Please enter your real name:\n", 29, 0);
//             return;
//         }

//         if (client->getStage() == WAITING_USERNAME)
//         {
            // line.erase(0, line.find_first_not_of(" "));
            // line.erase(line.find_last_not_of(" ") + 1);
            // if (line.empty() ) {
            //     send(client_fd, "Empty username. Try again:\n", 38, 0);
            //     return;
            // }
            // client->setRealname(line);
            // client->setStage(CONNECTED);
            // std::cout << "New client " << line << " connected with fd " << client_fd << ".\n";
            // send(client_fd, "You have successfully authenticated and joined the server.\n", 60, 0);
            // return;
//         }



//         if (client->getStage() == CONNECTED) {
            // std::string sender_nick = client->getNickname();
            // std::string full_message = "[Message from: " + sender_nick + "]: " + line + "\n";

            // std::cout << "--------------------------------------------\n";
            // std::cout << "[Message from: \033[1;34m" << sender_nick << "\033[0m]\n";
            // std::cout << "--------------------------------------------\n";
            // std::cout << "\033[1;32m" << line << "\033[0m\n";
            // std::cout << "--------------------------------------------\n";

            // handler.handleClientMessage(client_fd, line, *this);
//             //handler.sendToAllClients(full_message, client_fd, *this);
//         }
//     }
// }
void IRCServer::handleClientData(int client_fd, CommandHandler &handler) {
    char buffer[512];
    memset(buffer, 0, sizeof(buffer));
    int bytes_received = recv(client_fd, buffer, sizeof(buffer) - 1, 0);

    if (bytes_received < 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK)
            return;  // No hay datos ahora
        std::perror("recv handleClientData");
        removeClient(client_fd);
        return;
    }
    if (bytes_received == 0) {
        removeClient(client_fd);
        return;
    }

    buffer[bytes_received] = '\0';
    Client* client = clients_info.getClient(client_fd);
    if (!client) return;

    // ========= PROTECCIÓN CONTRA DoS ========= //
    // Verificar si el nuevo dato excede el límite del buffer
    if (client->getBuffer().size() + bytes_received > Client::MAX_BUFFER_SIZE) {
        std::cerr << "Client fd " << client_fd << " exceeded buffer limit (" 
                  << Client::MAX_BUFFER_SIZE << " bytes). Disconnecting." << std::endl;
        removeClient(client_fd);
        return;
    }
    
    // Añadir datos al buffer
    client->getBuffer() += buffer;
    
    // Procesar líneas completas
    size_t pos;
    while ((pos = client->getBuffer().find('\n')) != std::string::npos) {
        std::string line = client->getBuffer().substr(0, pos);
        client->getBuffer().erase(0, pos + 1);
        line.erase(line.find_last_not_of("\r\n") + 1);

        // ... [todo el código existente de procesamiento de estados] ...
        if (client->getStage() == WAITING_PASSWORD) {
            // ... [código existente] ...
            if (line != password) {
                send(client_fd, "Incorrect password. Connection closed.\n", 40, 0);
                removeClient(client_fd);
                return;
            }
            client->setStage(WAITING_NICKNAME);
            send(client_fd, "Please enter your nickname:\n", 29, 0);
            return;
        }
        else if (client->getStage() == WAITING_NICKNAME) {
            // ... [código existente] ...
            line.erase(0, line.find_first_not_of(" "));
            line.erase(line.find_last_not_of(" ") + 1);
            if (line.empty() || clients_info.nickExists(line)) {
                send(client_fd, "Nickname invalid or taken. Try again:\n", 38, 0);
                return;
            }
            client->setNickname(line);
            client->setStage(WAITING_USERNAME);
            send(client_fd, "Please enter your real name:\n", 29, 0);
            return;
        }
        else if (client->getStage() == WAITING_USERNAME) {
            // ... [código existente] ...
            line.erase(0, line.find_first_not_of(" "));
            line.erase(line.find_last_not_of(" ") + 1);
            if (line.empty() ) {
                send(client_fd, "Empty username. Try again:\n", 38, 0);
                return;
            }
            client->setRealname(line);
            client->setStage(CONNECTED);
            std::cout << "New client " << line << " connected with fd " << client_fd << ".\n";
            send(client_fd, "You have successfully authenticated and joined the server.\n", 60, 0);
            return;
        }
        else if (client->getStage() == CONNECTED) {
            // ... [código existente] ...
            std::string sender_nick = client->getNickname();
            std::string full_message = "[Message from: " + sender_nick + "]: " + line + "\n";

            std::cout << "--------------------------------------------\n";
            std::cout << "[Message from: \033[1;34m" << sender_nick << "\033[0m]\n";
            std::cout << "--------------------------------------------\n";
            std::cout << "\033[1;32m" << line << "\033[0m\n";
            std::cout << "--------------------------------------------\n";

            handler.handleClientMessage(client_fd, line, *this);
        }
    }

    // Verificación adicional para datos residuales sin \n
    if (client->getBuffer().size() > Client::MAX_BUFFER_SIZE) {
        std::cerr << "Client fd " << client_fd << " buffer overflow (" 
                  << client->getBuffer().size() << " > " 
                  << Client::MAX_BUFFER_SIZE << "). Disconnecting." << std::endl;
        removeClient(client_fd);
        return;
    }
}


// ===== Archivo: ./src/main.cpp ===== //
#include "Server.hpp"
#include <cstdlib>
#include <iostream>

int main(int argc, char* argv[]) {
     if (argc != 3) {
        std::cerr << "Usage: ./ircserv <port> <password>" << std::endl;
        return 1;
    }

    // Verificar que el puerto sea numérico
    for (char* p = argv[1]; *p; p++) {
        if (!std::isdigit(*p)) {
            std::cerr << "Invalid port: must be numeric" << std::endl;
            return 1;
        }
    }

    int port = std::atoi(argv[1]);
    if (port <= 0 || port > 65535) {
        std::cerr << "Invalid port number. Port must be between 1 and 65535." << std::endl;
        return 1;
    }

    std::string password = argv[2];
    if (password.empty()) {
        std::cerr << "Password cannot be empty." << std::endl;
        return 1;
    }

    IRCServer server(port, password);
    server.run();
    return 0;
}



// ===== Archivo: ./src/Client.cpp ===== //
#include "Client.hpp"

Client::Client() : fd(-1), nickname(""), realname("") {}

// Client::Client(int fd, std::string _nick) : fd(fd), nickname(_nick), realname("") {}

Client::Client(int fd, std::string _nick, std::string _user, AuthStage stage )
    : fd(fd), nickname(_nick), realname(_user),buffer(""), stage(stage) {}

std::string& Client::getBuffer() 
{ 
    return buffer; 
}

int Client::getFd() const {
    return fd;
}

void Client::setFd(int _fd) {
    fd = _fd;
}

std::string Client::getNickname() const {
    return nickname;
}

void Client::setNickname(const std::string& nick) {
    nickname = nick;
}

std::string Client::getRealname() const {
    return realname;
}

void Client::setRealname(const std::string& name) {
    realname = name;
}


AuthStage Client::getStage() const 
{ 
    return stage; 
}

void Client::setStage(AuthStage s) 
{ 
    stage = s; 
}

void Client::joinChannel(const std::string& channelName) {
    joinedChannels.insert(channelName);
}

void Client::leaveChannel(const std::string& channelName) {
    joinedChannels.erase(channelName);
}

bool Client::isInChannel(const std::string& channelName) const {
    return joinedChannels.find(channelName) != joinedChannels.end();
}

const std::set<std::string>& Client::getJoinedChannels() const {
    return joinedChannels;
}


